<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HighMap library (C++): hmap::Array Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HighMap library (C++)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classhmap_1_1Array.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classhmap_1_1Array-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">hmap::Array Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> class, helper to manipulate 2D float array with "(i, j)" indexing.  
 <a href="classhmap_1_1Array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="array_8hpp_source.html">array.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for hmap::Array:</div>
<div class="dyncontent">
<div class="center"><img src="classhmap_1_1Array__inherit__graph.png" border="0" usemap="#ahmap_1_1Array_inherit__map" alt="Inheritance graph"/></div>
<map name="ahmap_1_1Array_inherit__map" id="ahmap_1_1Array_inherit__map">
<area shape="rect" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing." alt="" coords="5,5,108,31"/>
<area shape="rect" href="classhmap_1_1Tile.html" title="Tile class, to manipulate a restricted region of an heightmap (with contextual informations)." alt="" coords="11,79,102,104"/>
<area shape="poly" title=" " alt="" coords="59,44,59,79,54,79,54,44"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for hmap::Array:</div>
<div class="dyncontent">
<div class="center"><img src="classhmap_1_1Array__coll__graph.png" border="0" usemap="#ahmap_1_1Array_coll__map" alt="Collaboration graph"/></div>
<map name="ahmap_1_1Array_coll__map" id="ahmap_1_1Array_coll__map">
<area shape="rect" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing." alt="" coords="112,93,215,119"/>
<area shape="rect" href="structhmap_1_1Vec2.html" title=" " alt="" coords="5,5,151,31"/>
<area shape="poly" title=" " alt="" coords="101,39,153,91,150,95,97,43"/>
<area shape="rect" title=" " alt="" coords="175,5,325,31"/>
<area shape="poly" title=" " alt="" coords="231,42,177,95,174,91,227,38"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a96b9bd19d1212e61b4ac4eb21931b298" id="r_a96b9bd19d1212e61b4ac4eb21931b298"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a96b9bd19d1212e61b4ac4eb21931b298">Array</a> ()</td></tr>
<tr class="memdesc:a96b9bd19d1212e61b4ac4eb21931b298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> object.  <br /></td></tr>
<tr class="separator:a96b9bd19d1212e61b4ac4eb21931b298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01be0e18bcfd224e61740d49929e8023" id="r_a01be0e18bcfd224e61740d49929e8023"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a01be0e18bcfd224e61740d49929e8023">Array</a> (<a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt; <a class="el" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>)</td></tr>
<tr class="memdesc:a01be0e18bcfd224e61740d49929e8023"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a01be0e18bcfd224e61740d49929e8023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885b4f45f50f0e7d9c32e316ecb9884b" id="r_a885b4f45f50f0e7d9c32e316ecb9884b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a885b4f45f50f0e7d9c32e316ecb9884b">Array</a> (<a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt; <a class="el" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>, float value)</td></tr>
<tr class="memdesc:a885b4f45f50f0e7d9c32e316ecb9884b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a885b4f45f50f0e7d9c32e316ecb9884b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad62b698ef12cfd06b3fb09e8cce7635" id="r_aad62b698ef12cfd06b3fb09e8cce7635"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#aad62b698ef12cfd06b3fb09e8cce7635">Array</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:aad62b698ef12cfd06b3fb09e8cce7635"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aad62b698ef12cfd06b3fb09e8cce7635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263037d82c46689a6575719b0054f10a" id="r_a263037d82c46689a6575719b0054f10a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a263037d82c46689a6575719b0054f10a">operator=</a> (const float value)</td></tr>
<tr class="memdesc:a263037d82c46689a6575719b0054f10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the assignment operator for scalar assignment.  <br /></td></tr>
<tr class="separator:a263037d82c46689a6575719b0054f10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412b5d0f678c59a3cde14395bbc83a3c" id="r_a412b5d0f678c59a3cde14395bbc83a3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a412b5d0f678c59a3cde14395bbc83a3c">operator*=</a> (const float value)</td></tr>
<tr class="memdesc:a412b5d0f678c59a3cde14395bbc83a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the multiplication-assignment operator for scalar multiplication.  <br /></td></tr>
<tr class="separator:a412b5d0f678c59a3cde14395bbc83a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad631aba3c1ded924c1cd3fe6abe4c45f" id="r_ad631aba3c1ded924c1cd3fe6abe4c45f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#ad631aba3c1ded924c1cd3fe6abe4c45f">operator*=</a> (const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;array)</td></tr>
<tr class="memdesc:ad631aba3c1ded924c1cd3fe6abe4c45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ad631aba3c1ded924c1cd3fe6abe4c45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c2d200c6d5ba12f172615313706e66" id="r_ac1c2d200c6d5ba12f172615313706e66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#ac1c2d200c6d5ba12f172615313706e66">operator/=</a> (const float value)</td></tr>
<tr class="memdesc:ac1c2d200c6d5ba12f172615313706e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the division-assignment operator for scalar division.  <br /></td></tr>
<tr class="separator:ac1c2d200c6d5ba12f172615313706e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0360b4113ba5284ab2579984e62a86c8" id="r_a0360b4113ba5284ab2579984e62a86c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a0360b4113ba5284ab2579984e62a86c8">operator/=</a> (const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;array)</td></tr>
<tr class="memdesc:a0360b4113ba5284ab2579984e62a86c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a0360b4113ba5284ab2579984e62a86c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc8f7bde72fd387cf660124feb33d25" id="r_a4bc8f7bde72fd387cf660124feb33d25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a4bc8f7bde72fd387cf660124feb33d25">operator+=</a> (const float value)</td></tr>
<tr class="memdesc:a4bc8f7bde72fd387cf660124feb33d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the addition-assignment operator for scalar addition.  <br /></td></tr>
<tr class="separator:a4bc8f7bde72fd387cf660124feb33d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af351b6eadd085e0821ace4b8f5196a6b" id="r_af351b6eadd085e0821ace4b8f5196a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#af351b6eadd085e0821ace4b8f5196a6b">operator+=</a> (const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;array)</td></tr>
<tr class="memdesc:af351b6eadd085e0821ace4b8f5196a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:af351b6eadd085e0821ace4b8f5196a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cdd9afcbe503938b7e9138b5064fb5" id="r_aa6cdd9afcbe503938b7e9138b5064fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#aa6cdd9afcbe503938b7e9138b5064fb5">operator-=</a> (const float value)</td></tr>
<tr class="memdesc:aa6cdd9afcbe503938b7e9138b5064fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the subtraction-assignment operator for scalar subtraction.  <br /></td></tr>
<tr class="separator:aa6cdd9afcbe503938b7e9138b5064fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6300da3f7c4b50be908858787b00cc80" id="r_a6300da3f7c4b50be908858787b00cc80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a6300da3f7c4b50be908858787b00cc80">operator-=</a> (const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;array)</td></tr>
<tr class="memdesc:a6300da3f7c4b50be908858787b00cc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a6300da3f7c4b50be908858787b00cc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b29fb20bdd0e1f9b76817f75e93347" id="r_ad4b29fb20bdd0e1f9b76817f75e93347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#ad4b29fb20bdd0e1f9b76817f75e93347">operator*</a> (const float value) const</td></tr>
<tr class="memdesc:ad4b29fb20bdd0e1f9b76817f75e93347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the multiplication operator for scalar multiplication.  <br /></td></tr>
<tr class="separator:ad4b29fb20bdd0e1f9b76817f75e93347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ede66a645d489770813dd75c62c01e" id="r_ae6ede66a645d489770813dd75c62c01e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#ae6ede66a645d489770813dd75c62c01e">operator*</a> (const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;array) const</td></tr>
<tr class="memdesc:ae6ede66a645d489770813dd75c62c01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the multiplication operator for element-wise multiplication with another array.  <br /></td></tr>
<tr class="separator:ae6ede66a645d489770813dd75c62c01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fc9b139538bac40998f9fcb44be678" id="r_ad1fc9b139538bac40998f9fcb44be678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#ad1fc9b139538bac40998f9fcb44be678">operator/</a> (const float value) const</td></tr>
<tr class="memdesc:ad1fc9b139538bac40998f9fcb44be678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the division operator for scalar division.  <br /></td></tr>
<tr class="separator:ad1fc9b139538bac40998f9fcb44be678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2371b22e560a6146b4b3248dde54beef" id="r_a2371b22e560a6146b4b3248dde54beef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a2371b22e560a6146b4b3248dde54beef">operator/</a> (const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;array) const</td></tr>
<tr class="memdesc:a2371b22e560a6146b4b3248dde54beef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the division operator for element-wise division by another array.  <br /></td></tr>
<tr class="separator:a2371b22e560a6146b4b3248dde54beef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a5f5334f2ced39ac8bf82085c04400" id="r_a39a5f5334f2ced39ac8bf82085c04400"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a39a5f5334f2ced39ac8bf82085c04400">operator+</a> (const float value) const</td></tr>
<tr class="memdesc:a39a5f5334f2ced39ac8bf82085c04400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the addition operator for scalar addition.  <br /></td></tr>
<tr class="separator:a39a5f5334f2ced39ac8bf82085c04400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818d037ead344885d52de41e03fb6ce2" id="r_a818d037ead344885d52de41e03fb6ce2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a818d037ead344885d52de41e03fb6ce2">operator+</a> (const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;array) const</td></tr>
<tr class="memdesc:a818d037ead344885d52de41e03fb6ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the addition operator for element-wise addition with another array.  <br /></td></tr>
<tr class="separator:a818d037ead344885d52de41e03fb6ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641951bf572b4f4122354b4249d24a53" id="r_a641951bf572b4f4122354b4249d24a53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a641951bf572b4f4122354b4249d24a53">operator-</a> () const</td></tr>
<tr class="memdesc:a641951bf572b4f4122354b4249d24a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the unary minus operator.  <br /></td></tr>
<tr class="separator:a641951bf572b4f4122354b4249d24a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799dfad6efda5d1ca9183164a54e5e1a" id="r_a799dfad6efda5d1ca9183164a54e5e1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a799dfad6efda5d1ca9183164a54e5e1a">operator-</a> (const float value) const</td></tr>
<tr class="memdesc:a799dfad6efda5d1ca9183164a54e5e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the subtraction operator for scalar subtraction.  <br /></td></tr>
<tr class="separator:a799dfad6efda5d1ca9183164a54e5e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f94f3bb00f0d5ac33a7e82d80366cc4" id="r_a5f94f3bb00f0d5ac33a7e82d80366cc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a5f94f3bb00f0d5ac33a7e82d80366cc4">operator-</a> (const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;array) const</td></tr>
<tr class="memdesc:a5f94f3bb00f0d5ac33a7e82d80366cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the subtraction operator for element-wise subtraction with another array.  <br /></td></tr>
<tr class="separator:a5f94f3bb00f0d5ac33a7e82d80366cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a812fa8efe5590cf0f1c619909eafe" id="r_ad8a812fa8efe5590cf0f1c619909eafe"><td class="memItemLeft" align="right" valign="top">float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#ad8a812fa8efe5590cf0f1c619909eafe">operator()</a> (int i, int j)</td></tr>
<tr class="memdesc:ad8a812fa8efe5590cf0f1c619909eafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the function call operator to access the array value at index (i, j).  <br /></td></tr>
<tr class="separator:ad8a812fa8efe5590cf0f1c619909eafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4befd40052e9d7390eb7499e592769e5" id="r_a4befd40052e9d7390eb7499e592769e5"><td class="memItemLeft" align="right" valign="top">const float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a4befd40052e9d7390eb7499e592769e5">operator()</a> (int i, int j) const</td></tr>
<tr class="memdesc:a4befd40052e9d7390eb7499e592769e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the function call operator to access the array value at index (i, j) (const version).  <br /></td></tr>
<tr class="separator:a4befd40052e9d7390eb7499e592769e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832a302b58fa7b346df04675a14ad59c" id="r_a832a302b58fa7b346df04675a14ad59c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a832a302b58fa7b346df04675a14ad59c">col_to_vector</a> (int j)</td></tr>
<tr class="memdesc:a832a302b58fa7b346df04675a14ad59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a column 'j' as a std::vector.  <br /></td></tr>
<tr class="separator:a832a302b58fa7b346df04675a14ad59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11949e2b41c869b364bc76129b4efeb4" id="r_a11949e2b41c869b364bc76129b4efeb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a11949e2b41c869b364bc76129b4efeb4">count_non_zero</a> ()</td></tr>
<tr class="memdesc:a11949e2b41c869b364bc76129b4efeb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of non-zero elements in the array.  <br /></td></tr>
<tr class="separator:a11949e2b41c869b364bc76129b4efeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec532fdab57a1b7571a0e273a567537c" id="r_aec532fdab57a1b7571a0e273a567537c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#aec532fdab57a1b7571a0e273a567537c">depose_amount_bilinear_at</a> (int i, int j, float u, float v, float amount)</td></tr>
<tr class="memdesc:aec532fdab57a1b7571a0e273a567537c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribute a value 'amount' around the four cells (i, j), (i + 1, j), (i, j + 1), (i + 1, j + 1) by "reversing" the bilinear interpolation.  <br /></td></tr>
<tr class="separator:aec532fdab57a1b7571a0e273a567537c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc07abfedb22639797124b951331ddf" id="r_a8bc07abfedb22639797124b951331ddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a8bc07abfedb22639797124b951331ddf">depose_amount_kernel_bilinear_at</a> (int i, int j, float u, float v, int ir, float amount)</td></tr>
<tr class="separator:a8bc07abfedb22639797124b951331ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c78b70cb181e3e43169b2b4e8d28e55" id="r_a8c78b70cb181e3e43169b2b4e8d28e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a8c78b70cb181e3e43169b2b4e8d28e55">depose_amount_kernel_at</a> (int i, int j, const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;kernel, float amount)</td></tr>
<tr class="memdesc:a8c78b70cb181e3e43169b2b4e8d28e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distributes a specified amount of value around the cell located at (i, j) using a 1D deposition kernel applied in both horizontal and vertical directions.  <br /></td></tr>
<tr class="separator:a8c78b70cb181e3e43169b2b4e8d28e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b8f7462c1e22b1da8a67ec62d4c8c8" id="r_a00b8f7462c1e22b1da8a67ec62d4c8c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a00b8f7462c1e22b1da8a67ec62d4c8c8">dump</a> (const std::string &amp;fname=&quot;out.png&quot;) const</td></tr>
<tr class="memdesc:a00b8f7462c1e22b1da8a67ec62d4c8c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug tool, dump some infos and generate an output file (16bits grayscale)  <br /></td></tr>
<tr class="separator:a00b8f7462c1e22b1da8a67ec62d4c8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57be73f56189959dd25a0b760d971bf7" id="r_a57be73f56189959dd25a0b760d971bf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a57be73f56189959dd25a0b760d971bf7">extract_slice</a> (<a class="el" href="structhmap_1_1Vec4.html">Vec4</a>&lt; int &gt; idx) const</td></tr>
<tr class="memdesc:a57be73f56189959dd25a0b760d971bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a subarray defined by the slice indices {i1, i2, j1, j2} from the original array, creating a new array. Note that i2 and j2 are excluded from the slice.  <br /></td></tr>
<tr class="separator:a57be73f56189959dd25a0b760d971bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d552a649bcc47445b11d2e42d193492" id="r_a7d552a649bcc47445b11d2e42d193492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a7d552a649bcc47445b11d2e42d193492">extract_slice</a> (int i1, int i2, int j1, int j2) const</td></tr>
<tr class="memdesc:a7d552a649bcc47445b11d2e42d193492"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7d552a649bcc47445b11d2e42d193492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000acd474d036adfa4e5e334139788ce" id="r_a000acd474d036adfa4e5e334139788ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a000acd474d036adfa4e5e334139788ce">from_file</a> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:a000acd474d036adfa4e5e334139788ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import array data from a raw binary file.  <br /></td></tr>
<tr class="separator:a000acd474d036adfa4e5e334139788ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b4eb10e50548b12cfd0cb2f9eddde1" id="r_a61b4eb10e50548b12cfd0cb2f9eddde1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a61b4eb10e50548b12cfd0cb2f9eddde1">from_numpy</a> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:a61b4eb10e50548b12cfd0cb2f9eddde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import array data from a numpy binary file.  <br /></td></tr>
<tr class="separator:a61b4eb10e50548b12cfd0cb2f9eddde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc074aa8ae60f52c105702637631e62" id="r_a1bc074aa8ae60f52c105702637631e62"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a1bc074aa8ae60f52c105702637631e62">get_gradient_x_at</a> (int i, int j) const</td></tr>
<tr class="memdesc:a1bc074aa8ae60f52c105702637631e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the gradient in the 'x' (or 'i') direction at a specified index (i, j) using a 2nd order central difference scheme.  <br /></td></tr>
<tr class="separator:a1bc074aa8ae60f52c105702637631e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe5c386af495d4648cdfa140f098398" id="r_acbe5c386af495d4648cdfa140f098398"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#acbe5c386af495d4648cdfa140f098398">get_gradient_y_at</a> (int i, int j) const</td></tr>
<tr class="memdesc:acbe5c386af495d4648cdfa140f098398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the gradient in the 'y' (or 'j') direction at a specified index (i, j) using a 2nd order central difference scheme.  <br /></td></tr>
<tr class="separator:acbe5c386af495d4648cdfa140f098398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c3088214a250b00d9e9649266e30d2" id="r_a80c3088214a250b00d9e9649266e30d2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a80c3088214a250b00d9e9649266e30d2">get_gradient_x_bilinear_at</a> (int i, int j, float u, float v) const</td></tr>
<tr class="memdesc:a80c3088214a250b00d9e9649266e30d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the gradient in the 'x' (or 'i') direction at a location (x, y) near the index (i, j) using bilinear interpolation.  <br /></td></tr>
<tr class="separator:a80c3088214a250b00d9e9649266e30d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8056879200c2cfa85a757e8c87bb3d" id="r_a5f8056879200c2cfa85a757e8c87bb3d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a5f8056879200c2cfa85a757e8c87bb3d">get_gradient_y_bilinear_at</a> (int i, int j, float u, float v) const</td></tr>
<tr class="memdesc:a5f8056879200c2cfa85a757e8c87bb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the gradient in the 'y' (or 'j') direction at a location (x, y) near the index (i, j) using bilinear interpolation.  <br /></td></tr>
<tr class="separator:a5f8056879200c2cfa85a757e8c87bb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e69d113a5b86b59e2bbf956262a2331" id="r_a0e69d113a5b86b59e2bbf956262a2331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhmap_1_1Vec3.html">Vec3</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a0e69d113a5b86b59e2bbf956262a2331">get_normal_at</a> (int i, int j) const</td></tr>
<tr class="memdesc:a0e69d113a5b86b59e2bbf956262a2331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the surface normal vector at the index (i, j).  <br /></td></tr>
<tr class="separator:a0e69d113a5b86b59e2bbf956262a2331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1496c702975e9425113eb4a1dd0e49c" id="r_ad1496c702975e9425113eb4a1dd0e49c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#ad1496c702975e9425113eb4a1dd0e49c">get_shape</a> ()</td></tr>
<tr class="memdesc:ad1496c702975e9425113eb4a1dd0e49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the shape of the array.  <br /></td></tr>
<tr class="separator:ad1496c702975e9425113eb4a1dd0e49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef7005c4ca95be75c82bded5165634c" id="r_a7ef7005c4ca95be75c82bded5165634c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a7ef7005c4ca95be75c82bded5165634c">get_sizeof</a> () const</td></tr>
<tr class="memdesc:a7ef7005c4ca95be75c82bded5165634c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of bytes occupied by the array data.  <br /></td></tr>
<tr class="separator:a7ef7005c4ca95be75c82bded5165634c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47cb152f3e887d17160519afd589ee2" id="r_ae47cb152f3e887d17160519afd589ee2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#ae47cb152f3e887d17160519afd589ee2">get_value_bicubic_at</a> (int i, int j, float u, float v) const</td></tr>
<tr class="memdesc:ae47cb152f3e887d17160519afd589ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the array value at the location (x, y) near the index (i, j) using bicubic interpolation.  <br /></td></tr>
<tr class="separator:ae47cb152f3e887d17160519afd589ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12eb51c18154e3e452afe9743636085f" id="r_a12eb51c18154e3e452afe9743636085f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a12eb51c18154e3e452afe9743636085f">get_value_bilinear_at</a> (int i, int j, float u, float v) const</td></tr>
<tr class="memdesc:a12eb51c18154e3e452afe9743636085f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the array value at the location (x, y) near the index (i, j) using bilinear interpolation.  <br /></td></tr>
<tr class="separator:a12eb51c18154e3e452afe9743636085f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd25996fe72213935f736f9fdb2c4d4" id="r_a9dd25996fe72213935f736f9fdb2c4d4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a9dd25996fe72213935f736f9fdb2c4d4">get_value_nearest</a> (float x, float y, <a class="el" href="structhmap_1_1Vec4.html">Vec4</a>&lt; float &gt; bbox)</td></tr>
<tr class="memdesc:a9dd25996fe72213935f736f9fdb2c4d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the nearest value at the location (x, y) within a bounded domain.  <br /></td></tr>
<tr class="separator:a9dd25996fe72213935f736f9fdb2c4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65336e3091ee64a91b3ecce8c01c837b" id="r_a65336e3091ee64a91b3ecce8c01c837b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a65336e3091ee64a91b3ecce8c01c837b">get_vector</a> () const</td></tr>
<tr class="memdesc:a65336e3091ee64a91b3ecce8c01c837b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the underlying data vector.  <br /></td></tr>
<tr class="separator:a65336e3091ee64a91b3ecce8c01c837b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3517b483a468873cefa73f7773a893ec" id="r_a3517b483a468873cefa73f7773a893ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a3517b483a468873cefa73f7773a893ec">infos</a> (std::string msg=&quot;&quot;) const</td></tr>
<tr class="memdesc:a3517b483a468873cefa73f7773a893ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display various information about the array.  <br /></td></tr>
<tr class="separator:a3517b483a468873cefa73f7773a893ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296cad1c7a3fd75b30a39a628bc7bcbe" id="r_a296cad1c7a3fd75b30a39a628bc7bcbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a296cad1c7a3fd75b30a39a628bc7bcbe">linear_index</a> (int i, int j) const</td></tr>
<tr class="memdesc:a296cad1c7a3fd75b30a39a628bc7bcbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linear index corresponding to the (i, j) cell in a 2D array.  <br /></td></tr>
<tr class="separator:a296cad1c7a3fd75b30a39a628bc7bcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9dda44818ef1fbd4228f42267cc305" id="r_a1d9dda44818ef1fbd4228f42267cc305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a1d9dda44818ef1fbd4228f42267cc305">linear_index_reverse</a> (int k) const</td></tr>
<tr class="memdesc:a1d9dda44818ef1fbd4228f42267cc305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a linear index to its corresponding (i, j) cell coordinates.  <br /></td></tr>
<tr class="separator:a1d9dda44818ef1fbd4228f42267cc305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68aac609ccba8f581da1cdf5cee671b9" id="r_a68aac609ccba8f581da1cdf5cee671b9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a68aac609ccba8f581da1cdf5cee671b9">max</a> () const</td></tr>
<tr class="memdesc:a68aac609ccba8f581da1cdf5cee671b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the greatest element in the array.  <br /></td></tr>
<tr class="separator:a68aac609ccba8f581da1cdf5cee671b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0c6960def9d61ed748ee6a787421a5" id="r_a1d0c6960def9d61ed748ee6a787421a5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a1d0c6960def9d61ed748ee6a787421a5">mean</a> () const</td></tr>
<tr class="memdesc:a1d0c6960def9d61ed748ee6a787421a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the mean value of the elements in the array.  <br /></td></tr>
<tr class="separator:a1d0c6960def9d61ed748ee6a787421a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c77f78e4864f5c6f2cbd6de8100556" id="r_a56c77f78e4864f5c6f2cbd6de8100556"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a56c77f78e4864f5c6f2cbd6de8100556">min</a> () const</td></tr>
<tr class="memdesc:a56c77f78e4864f5c6f2cbd6de8100556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the smallest element in the array.  <br /></td></tr>
<tr class="separator:a56c77f78e4864f5c6f2cbd6de8100556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55ee6021288a467f7d782b09e888f25" id="r_ab55ee6021288a467f7d782b09e888f25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#ab55ee6021288a467f7d782b09e888f25">normalize</a> ()</td></tr>
<tr class="memdesc:ab55ee6021288a467f7d782b09e888f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize array values so that the sum of all elements is equal to 1.  <br /></td></tr>
<tr class="separator:ab55ee6021288a467f7d782b09e888f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf76abbc7ad183514f41f2b54a0ad2e" id="r_a7bf76abbc7ad183514f41f2b54a0ad2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a7bf76abbc7ad183514f41f2b54a0ad2e">normalization_coeff</a> (float vmin=0.<a class="el" href="distance__transform_8cpp.html#abcb9259cf91bfd25e92a72cdf18c285e">f</a>, float vmax=1.<a class="el" href="distance__transform_8cpp.html#abcb9259cf91bfd25e92a72cdf18c285e">f</a>) const</td></tr>
<tr class="memdesc:a7bf76abbc7ad183514f41f2b54a0ad2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes normalization coefficients (a, b) such that a * array + b maps the values to the range [vmin, vmax].  <br /></td></tr>
<tr class="separator:a7bf76abbc7ad183514f41f2b54a0ad2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce20e5537ab2729aac320d0b27b7fa5" id="r_a7ce20e5537ab2729aac320d0b27b7fa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a7ce20e5537ab2729aac320d0b27b7fa5">print</a> () const</td></tr>
<tr class="memdesc:a7ce20e5537ab2729aac320d0b27b7fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the array values to the standard output (stdout).  <br /></td></tr>
<tr class="separator:a7ce20e5537ab2729aac320d0b27b7fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33557899eb50bcf964b2e5a2ad8ddcb" id="r_ac33557899eb50bcf964b2e5a2ad8ddcb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#ac33557899eb50bcf964b2e5a2ad8ddcb">ptp</a> () const</td></tr>
<tr class="memdesc:ac33557899eb50bcf964b2e5a2ad8ddcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the peak-to-peak amplitude (i.e., the difference between the maximum and minimum values) of the array values.  <br /></td></tr>
<tr class="separator:ac33557899eb50bcf964b2e5a2ad8ddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c242d119f67209442a0054601939412" id="r_a1c242d119f67209442a0054601939412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a1c242d119f67209442a0054601939412">resample_to_shape</a> (<a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt; new_shape) const</td></tr>
<tr class="memdesc:a1c242d119f67209442a0054601939412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a resampled array of shape <code>new_shape</code> using bilinear interpolation.  <br /></td></tr>
<tr class="separator:a1c242d119f67209442a0054601939412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36ac8e4689795d2e33b827a7f7b439c" id="r_af36ac8e4689795d2e33b827a7f7b439c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#af36ac8e4689795d2e33b827a7f7b439c">resample_to_shape_bicubic</a> (<a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt; new_shape) const</td></tr>
<tr class="memdesc:af36ac8e4689795d2e33b827a7f7b439c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a resampled array of shape <code>new_shape</code> using bicubic interpolation.  <br /></td></tr>
<tr class="separator:af36ac8e4689795d2e33b827a7f7b439c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2b1f8bbe8f6e28ebc0cc8616934601" id="r_a6f2b1f8bbe8f6e28ebc0cc8616934601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a6f2b1f8bbe8f6e28ebc0cc8616934601">resample_to_shape_bilinear</a> (<a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt; new_shape) const</td></tr>
<tr class="separator:a6f2b1f8bbe8f6e28ebc0cc8616934601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad438554fd7c3a7d705271e99f91d480c" id="r_ad438554fd7c3a7d705271e99f91d480c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#ad438554fd7c3a7d705271e99f91d480c">resample_to_shape_nearest</a> (<a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt; new_shape) const</td></tr>
<tr class="memdesc:ad438554fd7c3a7d705271e99f91d480c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a resampled array of shape <code>new_shape</code> using nearest neighbor interpolation.  <br /></td></tr>
<tr class="separator:ad438554fd7c3a7d705271e99f91d480c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d3cc92545cb9ee442d47b4d672750c" id="r_a82d3cc92545cb9ee442d47b4d672750c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a82d3cc92545cb9ee442d47b4d672750c">row_to_vector</a> (int i)</td></tr>
<tr class="memdesc:a82d3cc92545cb9ee442d47b4d672750c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row <code>i</code> as a <code>std::vector&lt;float&gt;</code>.  <br /></td></tr>
<tr class="separator:a82d3cc92545cb9ee442d47b4d672750c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2e167d01f42e3f953f6ad554c2b49d" id="r_a8f2e167d01f42e3f953f6ad554c2b49d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a8f2e167d01f42e3f953f6ad554c2b49d">set_shape</a> (<a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt; new_shape)</td></tr>
<tr class="memdesc:a8f2e167d01f42e3f953f6ad554c2b49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new shape for the array.  <br /></td></tr>
<tr class="separator:a8f2e167d01f42e3f953f6ad554c2b49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f0e0817bbb740e3350adaca187743e" id="r_a11f0e0817bbb740e3350adaca187743e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a11f0e0817bbb740e3350adaca187743e">set_slice</a> (<a class="el" href="structhmap_1_1Vec4.html">Vec4</a>&lt; int &gt; idx, float value)</td></tr>
<tr class="memdesc:a11f0e0817bbb740e3350adaca187743e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a slice defined by indices {i1, i2, j1, j2} to a new value.  <br /></td></tr>
<tr class="separator:a11f0e0817bbb740e3350adaca187743e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362927ee451f7546cfd37f0850982ed3" id="r_a362927ee451f7546cfd37f0850982ed3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a362927ee451f7546cfd37f0850982ed3">set_slice</a> (<a class="el" href="structhmap_1_1Vec4.html">Vec4</a>&lt; int &gt; idx, const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;array)</td></tr>
<tr class="memdesc:a362927ee451f7546cfd37f0850982ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a362927ee451f7546cfd37f0850982ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e6671dbf3202dbc86f5eccb0fcb1ad" id="r_a16e6671dbf3202dbc86f5eccb0fcb1ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a16e6671dbf3202dbc86f5eccb0fcb1ad">size</a> () const</td></tr>
<tr class="memdesc:a16e6671dbf3202dbc86f5eccb0fcb1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of elements in the array.  <br /></td></tr>
<tr class="separator:a16e6671dbf3202dbc86f5eccb0fcb1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa913be411b57b6a46b45dd3d5ddefcfd" id="r_aa913be411b57b6a46b45dd3d5ddefcfd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#aa913be411b57b6a46b45dd3d5ddefcfd">std</a> () const</td></tr>
<tr class="memdesc:aa913be411b57b6a46b45dd3d5ddefcfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the standard deviation of all array values.  <br /></td></tr>
<tr class="separator:aa913be411b57b6a46b45dd3d5ddefcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee63fb7135276ed8d6643d082f06892" id="r_a7ee63fb7135276ed8d6643d082f06892"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a7ee63fb7135276ed8d6643d082f06892">sum</a> () const</td></tr>
<tr class="memdesc:a7ee63fb7135276ed8d6643d082f06892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of all array values.  <br /></td></tr>
<tr class="separator:a7ee63fb7135276ed8d6643d082f06892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4875ad6cfe16bd03004ba52f94587c" id="r_abc4875ad6cfe16bd03004ba52f94587c"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#abc4875ad6cfe16bd03004ba52f94587c">to_cv_mat</a> ()</td></tr>
<tr class="memdesc:abc4875ad6cfe16bd03004ba52f94587c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a 2D <code><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a></code> to an OpenCV <code>cv::Mat</code>.  <br /></td></tr>
<tr class="separator:abc4875ad6cfe16bd03004ba52f94587c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa681ff740560464d3830d5f7259282fd" id="r_aa681ff740560464d3830d5f7259282fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#aa681ff740560464d3830d5f7259282fd">to_exr</a> (const std::string &amp;fname) const</td></tr>
<tr class="memdesc:aa681ff740560464d3830d5f7259282fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the array as an OpenEXR image file.  <br /></td></tr>
<tr class="separator:aa681ff740560464d3830d5f7259282fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd8060670649c0934ddab573e378d3f" id="r_a6cd8060670649c0934ddab573e378d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a6cd8060670649c0934ddab573e378d3f">to_file</a> (const std::string &amp;fname) const</td></tr>
<tr class="memdesc:a6cd8060670649c0934ddab573e378d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the array to a raw binary file.  <br /></td></tr>
<tr class="separator:a6cd8060670649c0934ddab573e378d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ce8d4088ce4ae21003df18c204b7c6" id="r_a35ce8d4088ce4ae21003df18c204b7c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a35ce8d4088ce4ae21003df18c204b7c6">to_numpy</a> (const std::string &amp;fname) const</td></tr>
<tr class="memdesc:a35ce8d4088ce4ae21003df18c204b7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the array to a numpy binary file.  <br /></td></tr>
<tr class="separator:a35ce8d4088ce4ae21003df18c204b7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff7b2c0be8f2b5dd9fc33085cd647d1" id="r_a9ff7b2c0be8f2b5dd9fc33085cd647d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a9ff7b2c0be8f2b5dd9fc33085cd647d1">to_png</a> (const std::string &amp;fname, int cmap, bool hillshading=false, int depth=CV_8U) const</td></tr>
<tr class="memdesc:a9ff7b2c0be8f2b5dd9fc33085cd647d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the array as a PNG image file with a specified colormap and hillshading.  <br /></td></tr>
<tr class="separator:a9ff7b2c0be8f2b5dd9fc33085cd647d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7018857827d8e8d263516bbbd77630f" id="r_ad7018857827d8e8d263516bbbd77630f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#ad7018857827d8e8d263516bbbd77630f">to_png_grayscale</a> (const std::string &amp;fname, int depth=CV_8U) const</td></tr>
<tr class="memdesc:ad7018857827d8e8d263516bbbd77630f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the array as a grayscale PNG image file with specified bit depth.  <br /></td></tr>
<tr class="separator:ad7018857827d8e8d263516bbbd77630f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75da0609f64b9410741d198330dde33b" id="r_a75da0609f64b9410741d198330dde33b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a75da0609f64b9410741d198330dde33b">to_tiff</a> (const std::string &amp;fname) const</td></tr>
<tr class="memdesc:a75da0609f64b9410741d198330dde33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the array as a TIFF image file.  <br /></td></tr>
<tr class="separator:a75da0609f64b9410741d198330dde33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc72128c4c460e993d877cab54e17454" id="r_abc72128c4c460e993d877cab54e17454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#abc72128c4c460e993d877cab54e17454">to_raw_16bit</a> (const std::string &amp;fname) const</td></tr>
<tr class="memdesc:abc72128c4c460e993d877cab54e17454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export the array as a 16-bit raw file for Unity terrain import.  <br /></td></tr>
<tr class="separator:abc72128c4c460e993d877cab54e17454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4ea8fbdc162b16a2b0c8de575ff569" id="r_acc4ea8fbdc162b16a2b0c8de575ff569"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#acc4ea8fbdc162b16a2b0c8de575ff569">unique_values</a> ()</td></tr>
<tr class="memdesc:acc4ea8fbdc162b16a2b0c8de575ff569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unique elements of the array.  <br /></td></tr>
<tr class="separator:acc4ea8fbdc162b16a2b0c8de575ff569"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3cf6ada373f8af1affcbbed22db1194f" id="r_a3cf6ada373f8af1affcbbed22db1194f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a></td></tr>
<tr class="memdesc:a3cf6ada373f8af1affcbbed22db1194f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The shape of the array {ni, nj}.  <br /></td></tr>
<tr class="separator:a3cf6ada373f8af1affcbbed22db1194f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af586ddce153ac93df48a6d26609d7264" id="r_af586ddce153ac93df48a6d26609d7264"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#af586ddce153ac93df48a6d26609d7264">vector</a></td></tr>
<tr class="memdesc:af586ddce153ac93df48a6d26609d7264"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying data storage, a vector of size shape.x * shape.y.  <br /></td></tr>
<tr class="separator:af586ddce153ac93df48a6d26609d7264"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a58ffc99dbcc9c7e8c0dc186202635a4f" id="r_a58ffc99dbcc9c7e8c0dc186202635a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a58ffc99dbcc9c7e8c0dc186202635a4f">operator*</a> (const float value, const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;array)</td></tr>
<tr class="memdesc:a58ffc99dbcc9c7e8c0dc186202635a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the multiplication operator for scalar multiplication.  <br /></td></tr>
<tr class="separator:a58ffc99dbcc9c7e8c0dc186202635a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0bbf93f6dba016b681ac09274b5c66" id="r_aaf0bbf93f6dba016b681ac09274b5c66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#aaf0bbf93f6dba016b681ac09274b5c66">operator/</a> (const float value, const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;array)</td></tr>
<tr class="memdesc:aaf0bbf93f6dba016b681ac09274b5c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the division operator for scalar division.  <br /></td></tr>
<tr class="separator:aaf0bbf93f6dba016b681ac09274b5c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3286ad1492734bca2ad2412b833c65f1" id="r_a3286ad1492734bca2ad2412b833c65f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a3286ad1492734bca2ad2412b833c65f1">operator+</a> (const float value, const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;array)</td></tr>
<tr class="memdesc:a3286ad1492734bca2ad2412b833c65f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the addition operator for scalar addition.  <br /></td></tr>
<tr class="separator:a3286ad1492734bca2ad2412b833c65f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db4ef63385d15069d4ee57c80906d5d" id="r_a3db4ef63385d15069d4ee57c80906d5d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhmap_1_1Array.html">Array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhmap_1_1Array.html#a3db4ef63385d15069d4ee57c80906d5d">operator-</a> (const float value, const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;array)</td></tr>
<tr class="memdesc:a3db4ef63385d15069d4ee57c80906d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads the subtraction operator for scalar subtraction.  <br /></td></tr>
<tr class="separator:a3db4ef63385d15069d4ee57c80906d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> class, helper to manipulate 2D float array with "(i, j)" indexing. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a96b9bd19d1212e61b4ac4eb21931b298" name="a96b9bd19d1212e61b4ac4eb21931b298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b9bd19d1212e61b4ac4eb21931b298">&#9670;&#160;</a></span>Array() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hmap::Array::Array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The shape of the array {ni, nj}. </td></tr>
    <tr><td class="paramname">value</td><td>The initial value to fill the array with.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example #1</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="highmap_8hpp.html">highmap.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;int&gt;</a> <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a> = {6, 4};</div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a>     a = <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a>(<a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>);</div>
<div class="line"> </div>
<div class="line">  a = 1.f;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; a.<a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>.<a class="code hl_variable" href="structhmap_1_1Vec2.html#a2dc51e83492f966eeddbdac3d58ab447">x</a>; i++)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; a.<a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>.<a class="code hl_variable" href="structhmap_1_1Vec2.html#a087ff9ff4159d1e5778c0b65ee2a1648">y</a>; j++)</div>
<div class="line">      std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; j &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; a(i, j) &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="ttc" id="aclasshmap_1_1Array_html"><div class="ttname"><a href="classhmap_1_1Array.html">hmap::Array</a></div><div class="ttdoc">Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.</div><div class="ttdef"><b>Definition</b> array.hpp:32</div></div>
<div class="ttc" id="aclasshmap_1_1Array_html_a3cf6ada373f8af1affcbbed22db1194f"><div class="ttname"><a href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">hmap::Array::shape</a></div><div class="ttdeci">Vec2&lt; int &gt; shape</div><div class="ttdoc">The shape of the array {ni, nj}.</div><div class="ttdef"><b>Definition</b> array.hpp:38</div></div>
<div class="ttc" id="ahighmap_8hpp_html"><div class="ttname"><a href="highmap_8hpp.html">highmap.hpp</a></div></div>
<div class="ttc" id="astructhmap_1_1Vec2_html"><div class="ttname"><a href="structhmap_1_1Vec2.html">hmap::Vec2</a></div><div class="ttdoc">Vec2 class for basic manipulation of 2D vectors.</div><div class="ttdef"><b>Definition</b> algebra.hpp:40</div></div>
<div class="ttc" id="astructhmap_1_1Vec2_html_a087ff9ff4159d1e5778c0b65ee2a1648"><div class="ttname"><a href="structhmap_1_1Vec2.html#a087ff9ff4159d1e5778c0b65ee2a1648">hmap::Vec2::y</a></div><div class="ttdeci">T y</div><div class="ttdoc">The x and y components of the vector.</div><div class="ttdef"><b>Definition</b> algebra.hpp:41</div></div>
<div class="ttc" id="astructhmap_1_1Vec2_html_a2dc51e83492f966eeddbdac3d58ab447"><div class="ttname"><a href="structhmap_1_1Vec2.html#a2dc51e83492f966eeddbdac3d58ab447">hmap::Vec2::x</a></div><div class="ttdeci">T x</div><div class="ttdef"><b>Definition</b> algebra.hpp:41</div></div>
</div><!-- fragment --><p><b>Example #2</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="highmap_8hpp.html">highmap.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;int&gt;</a>   <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a> = {512, 512};</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;float&gt;</a> res = {4.f, 4.f};</div>
<div class="line">  <span class="keywordtype">int</span>                     seed = 2;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// write png</span></div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z1 = <a class="code hl_function" href="namespacehmap.html#a40b948c49a05c14f2d540dc1a6952130">hmap::noise_fbm</a>(<a class="code hl_enumvalue" href="namespacehmap.html#ab8197c4c7a85dacb616fee7a7d0df195a87c6abee9c8e2441859223b28e9b4581">hmap::NoiseType::PERLIN</a>,</div>
<div class="line">                                   <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>,</div>
<div class="line">                                   res,</div>
<div class="line">                                   seed,</div>
<div class="line">                                   8);</div>
<div class="line">  <a class="code hl_function" href="namespacehmap.html#a262e6495cb2d02598f36a2b46114b2b4">hmap::remap</a>(z1);</div>
<div class="line">  z1.<a class="code hl_function" href="classhmap_1_1Array.html#a9ff7b2c0be8f2b5dd9fc33085cd647d1">to_png</a>(<span class="stringliteral">&quot;out_rgb.png&quot;</span>, <a class="code hl_enumvalue" href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369a65146260717d07e4773aec50520b9ced">hmap::Cmap::JET</a>);</div>
<div class="line">  z1.<a class="code hl_function" href="classhmap_1_1Array.html#ad7018857827d8e8d263516bbbd77630f">to_png_grayscale</a>(<span class="stringliteral">&quot;out_8bit.png&quot;</span>);</div>
<div class="line">  z1.<a class="code hl_function" href="classhmap_1_1Array.html#ad7018857827d8e8d263516bbbd77630f">to_png_grayscale</a>(<span class="stringliteral">&quot;out_16bit.png&quot;</span>, CV_16U);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create Array from png</span></div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z2 = <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a>(<span class="stringliteral">&quot;out_8bit.png&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z3 = <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a>(<span class="stringliteral">&quot;out_16bit.png&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  z1.<a class="code hl_function" href="classhmap_1_1Array.html#abc72128c4c460e993d877cab54e17454">to_raw_16bit</a>(<span class="stringliteral">&quot;out.raw&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacehmap.html#a1c490f296571a75e35d05b10c075ae6c">hmap::export_banner_png</a>(<span class="stringliteral">&quot;ex_to_png.png&quot;</span>, {z1, z2, z3}, <a class="code hl_enumvalue" href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369afd0b9cd53cbae62c25ef686ba527d143">hmap::Cmap::INFERNO</a>);</div>
<div class="line">}</div>
<div class="ttc" id="aclasshmap_1_1Array_html_a9ff7b2c0be8f2b5dd9fc33085cd647d1"><div class="ttname"><a href="classhmap_1_1Array.html#a9ff7b2c0be8f2b5dd9fc33085cd647d1">hmap::Array::to_png</a></div><div class="ttdeci">void to_png(const std::string &amp;fname, int cmap, bool hillshading=false, int depth=CV_8U) const</div><div class="ttdoc">Export the array as a PNG image file with a specified colormap and hillshading.</div><div class="ttdef"><b>Definition</b> io.cpp:122</div></div>
<div class="ttc" id="aclasshmap_1_1Array_html_abc72128c4c460e993d877cab54e17454"><div class="ttname"><a href="classhmap_1_1Array.html#abc72128c4c460e993d877cab54e17454">hmap::Array::to_raw_16bit</a></div><div class="ttdeci">void to_raw_16bit(const std::string &amp;fname) const</div><div class="ttdoc">Export the array as a 16-bit raw file for Unity terrain import.</div><div class="ttdef"><b>Definition</b> io.cpp:148</div></div>
<div class="ttc" id="aclasshmap_1_1Array_html_ad7018857827d8e8d263516bbbd77630f"><div class="ttname"><a href="classhmap_1_1Array.html#ad7018857827d8e8d263516bbbd77630f">hmap::Array::to_png_grayscale</a></div><div class="ttdeci">void to_png_grayscale(const std::string &amp;fname, int depth=CV_8U) const</div><div class="ttdoc">Export the array as a grayscale PNG image file with specified bit depth.</div><div class="ttdef"><b>Definition</b> io.cpp:136</div></div>
<div class="ttc" id="anamespacehmap_html_a1c490f296571a75e35d05b10c075ae6c"><div class="ttname"><a href="namespacehmap.html#a1c490f296571a75e35d05b10c075ae6c">hmap::export_banner_png</a></div><div class="ttdeci">void export_banner_png(const std::string &amp;fname, const std::vector&lt; Array &gt; &amp;arrays, int cmap, bool hillshading=false)</div><div class="ttdoc">Exports a set of arrays as a banner PNG image file.</div><div class="ttdef"><b>Definition</b> export_banner_png.cpp:11</div></div>
<div class="ttc" id="anamespacehmap_html_a262e6495cb2d02598f36a2b46114b2b4"><div class="ttname"><a href="namespacehmap.html#a262e6495cb2d02598f36a2b46114b2b4">hmap::remap</a></div><div class="ttdeci">void remap(Array &amp;array, float vmin, float vmax, float from_min, float from_max)</div><div class="ttdoc">Remap array elements from a starting range to a target range.</div><div class="ttdef"><b>Definition</b> range.cpp:374</div></div>
<div class="ttc" id="anamespacehmap_html_a40b948c49a05c14f2d540dc1a6952130"><div class="ttname"><a href="namespacehmap.html#a40b948c49a05c14f2d540dc1a6952130">hmap::noise_fbm</a></div><div class="ttdeci">Array noise_fbm(NoiseType noise_type, Vec2&lt; int &gt; shape, Vec2&lt; float &gt; kw, uint seed, int octaves=8, float weight=0.7f, float persistence=0.5f, float lacunarity=2.f, const Array *p_ctrl_param=nullptr, const Array *p_noise_x=nullptr, const Array *p_noise_y=nullptr, const Array *p_stretching=nullptr, Vec4&lt; float &gt; bbox={0.f, 1.f, 0.f, 1.f})</div><div class="ttdoc">Return an array filled with coherence fbm noise.</div><div class="ttdef"><b>Definition</b> noise.cpp:41</div></div>
<div class="ttc" id="anamespacehmap_html_ab8197c4c7a85dacb616fee7a7d0df195a87c6abee9c8e2441859223b28e9b4581"><div class="ttname"><a href="namespacehmap.html#ab8197c4c7a85dacb616fee7a7d0df195a87c6abee9c8e2441859223b28e9b4581">hmap::PERLIN</a></div><div class="ttdeci">@ PERLIN</div><div class="ttdoc">Perlin.</div><div class="ttdef"><b>Definition</b> functions.hpp:47</div></div>
<div class="ttc" id="anamespacehmap_html_ac70fe3cbb32e0340d5dd3e15cdcf9369a65146260717d07e4773aec50520b9ced"><div class="ttname"><a href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369a65146260717d07e4773aec50520b9ced">hmap::JET</a></div><div class="ttdeci">@ JET</div><div class="ttdef"><b>Definition</b> colormaps.hpp:86</div></div>
<div class="ttc" id="anamespacehmap_html_ac70fe3cbb32e0340d5dd3e15cdcf9369afd0b9cd53cbae62c25ef686ba527d143"><div class="ttname"><a href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369afd0b9cd53cbae62c25ef686ba527d143">hmap::INFERNO</a></div><div class="ttdeci">@ INFERNO</div><div class="ttdef"><b>Definition</b> colormaps.hpp:85</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a01be0e18bcfd224e61740d49929e8023" name="a01be0e18bcfd224e61740d49929e8023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01be0e18bcfd224e61740d49929e8023">&#9670;&#160;</a></span>Array() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hmap::Array::Array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a885b4f45f50f0e7d9c32e316ecb9884b" name="a885b4f45f50f0e7d9c32e316ecb9884b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885b4f45f50f0e7d9c32e316ecb9884b">&#9670;&#160;</a></span>Array() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hmap::Array::Array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aad62b698ef12cfd06b3fb09e8cce7635" name="aad62b698ef12cfd06b3fb09e8cce7635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad62b698ef12cfd06b3fb09e8cce7635">&#9670;&#160;</a></span>Array() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hmap::Array::Array </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a263037d82c46689a6575719b0054f10a" name="a263037d82c46689a6575719b0054f10a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263037d82c46689a6575719b0054f10a">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp; hmap::Array::operator= </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the assignment operator for scalar assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar value to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a>&amp; Reference to the current <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> object. </dd></dl>

</div>
</div>
<a id="a412b5d0f678c59a3cde14395bbc83a3c" name="a412b5d0f678c59a3cde14395bbc83a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412b5d0f678c59a3cde14395bbc83a3c">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp; hmap::Array::operator*= </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the multiplication-assignment operator for scalar multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar value to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a>&amp; Reference to the current <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> object. </dd></dl>

</div>
</div>
<a id="ad631aba3c1ded924c1cd3fe6abe4c45f" name="ad631aba3c1ded924c1cd3fe6abe4c45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad631aba3c1ded924c1cd3fe6abe4c45f">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp; hmap::Array::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ac1c2d200c6d5ba12f172615313706e66" name="ac1c2d200c6d5ba12f172615313706e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c2d200c6d5ba12f172615313706e66">&#9670;&#160;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp; hmap::Array::operator/= </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the division-assignment operator for scalar division. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar value to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a>&amp; Reference to the current <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> object. </dd></dl>

</div>
</div>
<a id="a0360b4113ba5284ab2579984e62a86c8" name="a0360b4113ba5284ab2579984e62a86c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0360b4113ba5284ab2579984e62a86c8">&#9670;&#160;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp; hmap::Array::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a4bc8f7bde72fd387cf660124feb33d25" name="a4bc8f7bde72fd387cf660124feb33d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc8f7bde72fd387cf660124feb33d25">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp; hmap::Array::operator+= </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the addition-assignment operator for scalar addition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a>&amp; Reference to the current <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> object. </dd></dl>

</div>
</div>
<a id="af351b6eadd085e0821ace4b8f5196a6b" name="af351b6eadd085e0821ace4b8f5196a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af351b6eadd085e0821ace4b8f5196a6b">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp; hmap::Array::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa6cdd9afcbe503938b7e9138b5064fb5" name="aa6cdd9afcbe503938b7e9138b5064fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6cdd9afcbe503938b7e9138b5064fb5">&#9670;&#160;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp; hmap::Array::operator-= </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the subtraction-assignment operator for scalar subtraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar value to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a>&amp; Reference to the current <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> object. </dd></dl>

</div>
</div>
<a id="a6300da3f7c4b50be908858787b00cc80" name="a6300da3f7c4b50be908858787b00cc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6300da3f7c4b50be908858787b00cc80">&#9670;&#160;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> &amp; hmap::Array::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad4b29fb20bdd0e1f9b76817f75e93347" name="ad4b29fb20bdd0e1f9b76817f75e93347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b29fb20bdd0e1f9b76817f75e93347">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the multiplication operator for scalar multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar value to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resulting <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> after multiplication. </dd></dl>

</div>
</div>
<a id="ae6ede66a645d489770813dd75c62c01e" name="ae6ede66a645d489770813dd75c62c01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ede66a645d489770813dd75c62c01e">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the multiplication operator for element-wise multiplication with another array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> to multiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resulting <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> after element-wise multiplication. </dd></dl>

</div>
</div>
<a id="ad1fc9b139538bac40998f9fcb44be678" name="ad1fc9b139538bac40998f9fcb44be678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1fc9b139538bac40998f9fcb44be678">&#9670;&#160;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::operator/ </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the division operator for scalar division. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar value to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resulting <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> after division. </dd></dl>

</div>
</div>
<a id="a2371b22e560a6146b4b3248dde54beef" name="a2371b22e560a6146b4b3248dde54beef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2371b22e560a6146b4b3248dde54beef">&#9670;&#160;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the division operator for element-wise division by another array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resulting <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> after element-wise division. </dd></dl>

</div>
</div>
<a id="a39a5f5334f2ced39ac8bf82085c04400" name="a39a5f5334f2ced39ac8bf82085c04400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a5f5334f2ced39ac8bf82085c04400">&#9670;&#160;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::operator+ </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the addition operator for scalar addition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resulting <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> after addition. </dd></dl>

</div>
</div>
<a id="a818d037ead344885d52de41e03fb6ce2" name="a818d037ead344885d52de41e03fb6ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818d037ead344885d52de41e03fb6ce2">&#9670;&#160;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the addition operator for element-wise addition with another array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resulting <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> after element-wise addition. </dd></dl>

</div>
</div>
<a id="a641951bf572b4f4122354b4249d24a53" name="a641951bf572b4f4122354b4249d24a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641951bf572b4f4122354b4249d24a53">&#9670;&#160;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the unary minus operator. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resulting <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> after applying the unary minus. </dd></dl>

</div>
</div>
<a id="a799dfad6efda5d1ca9183164a54e5e1a" name="a799dfad6efda5d1ca9183164a54e5e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799dfad6efda5d1ca9183164a54e5e1a">&#9670;&#160;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::operator- </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the subtraction operator for scalar subtraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar value to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resulting <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> after subtraction. </dd></dl>

</div>
</div>
<a id="a5f94f3bb00f0d5ac33a7e82d80366cc4" name="a5f94f3bb00f0d5ac33a7e82d80366cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f94f3bb00f0d5ac33a7e82d80366cc4">&#9670;&#160;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads the subtraction operator for element-wise subtraction with another array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> to subtract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resulting <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> after element-wise subtraction. </dd></dl>

</div>
</div>
<a id="ad8a812fa8efe5590cf0f1c619909eafe" name="ad8a812fa8efe5590cf0f1c619909eafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a812fa8efe5590cf0f1c619909eafe">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float &amp; hmap::Array::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the function call operator to access the array value at index (i, j). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index. </td></tr>
    <tr><td class="paramname">j</td><td>The column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float&amp; Reference to the array value at index (i, j). </dd></dl>

</div>
</div>
<a id="a4befd40052e9d7390eb7499e592769e5" name="a4befd40052e9d7390eb7499e592769e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4befd40052e9d7390eb7499e592769e5">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float &amp; hmap::Array::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the function call operator to access the array value at index (i, j) (const version). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index. </td></tr>
    <tr><td class="paramname">j</td><td>The column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const float&amp; Reference to the array value at index (i, j). &lt;This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </dd></dl>

</div>
</div>
<a id="a832a302b58fa7b346df04675a14ad59c" name="a832a302b58fa7b346df04675a14ad59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832a302b58fa7b346df04675a14ad59c">&#9670;&#160;</a></span>col_to_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; hmap::Array::col_to_vector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a column 'j' as a std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">j</td><td>The column index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;float&gt; The column values as a vector. </dd></dl>

</div>
</div>
<a id="a11949e2b41c869b364bc76129b4efeb4" name="a11949e2b41c869b364bc76129b4efeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11949e2b41c869b364bc76129b4efeb4">&#9670;&#160;</a></span>count_non_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hmap::Array::count_non_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of non-zero elements in the array. </p>
<dl class="section return"><dt>Returns</dt><dd>int The number of non-zero elements. </dd></dl>

</div>
</div>
<a id="aec532fdab57a1b7571a0e273a567537c" name="aec532fdab57a1b7571a0e273a567537c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec532fdab57a1b7571a0e273a567537c">&#9670;&#160;</a></span>depose_amount_bilinear_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::depose_amount_bilinear_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distribute a value 'amount' around the four cells (i, j), (i + 1, j), (i, j + 1), (i + 1, j + 1) by "reversing" the bilinear interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index. </td></tr>
    <tr><td class="paramname">j</td><td>Index. </td></tr>
    <tr><td class="paramname">u</td><td>'u' interpolation parameter, expected to be in [0, 1[. </td></tr>
    <tr><td class="paramname">v</td><td>'v' interpolation parameter, expected to be in [0, 1[. </td></tr>
    <tr><td class="paramname">amount</td><td>Amount to be deposited. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bc07abfedb22639797124b951331ddf" name="a8bc07abfedb22639797124b951331ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc07abfedb22639797124b951331ddf">&#9670;&#160;</a></span>depose_amount_kernel_bilinear_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::depose_amount_kernel_bilinear_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c78b70cb181e3e43169b2b4e8d28e55" name="a8c78b70cb181e3e43169b2b4e8d28e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c78b70cb181e3e43169b2b4e8d28e55">&#9670;&#160;</a></span>depose_amount_kernel_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::depose_amount_kernel_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distributes a specified amount of value around the cell located at (i, j) using a 1D deposition kernel applied in both horizontal and vertical directions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index of the cell in the array where the deposition starts. </td></tr>
    <tr><td class="paramname">j</td><td>Index of the cell in the array where the deposition starts. </td></tr>
    <tr><td class="paramname">kernel</td><td>1D deposition kernel to be used for distribution. The kernel must contain an odd number of elements. </td></tr>
    <tr><td class="paramname">amount</td><td>The amount of value to be distributed around the cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00b8f7462c1e22b1da8a67ec62d4c8c8" name="a00b8f7462c1e22b1da8a67ec62d4c8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b8f7462c1e22b1da8a67ec62d4c8c8">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::dump </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em> = <code>&quot;out.png&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debug tool, dump some infos and generate an output file (16bits grayscale) </p>

</div>
</div>
<a id="a57be73f56189959dd25a0b760d971bf7" name="a57be73f56189959dd25a0b760d971bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57be73f56189959dd25a0b760d971bf7">&#9670;&#160;</a></span>extract_slice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::extract_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmap_1_1Vec4.html">Vec4</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a subarray defined by the slice indices {i1, i2, j1, j2} from the original array, creating a new array. Note that i2 and j2 are excluded from the slice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>A Vec4&lt;int&gt; containing the slice extent indices {i1, i2, j1, j2}. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The extracted subarray. </dd></dl>

</div>
</div>
<a id="a7d552a649bcc47445b11d2e42d193492" name="a7d552a649bcc47445b11d2e42d193492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d552a649bcc47445b11d2e42d193492">&#9670;&#160;</a></span>extract_slice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::extract_slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a000acd474d036adfa4e5e334139788ce" name="a000acd474d036adfa4e5e334139788ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000acd474d036adfa4e5e334139788ce">&#9670;&#160;</a></span>from_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::from_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import array data from a raw binary file. </p>
<pre class="fragment">   This function loads the array data from a binary file specified by
</pre><p> <code>fname</code>. The file should contain raw binary data that corresponds to the internal representation of the array. The array's size and data type must match the expected format in the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the file to import data from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61b4eb10e50548b12cfd0cb2f9eddde1" name="a61b4eb10e50548b12cfd0cb2f9eddde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b4eb10e50548b12cfd0cb2f9eddde1">&#9670;&#160;</a></span>from_numpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::from_numpy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import array data from a numpy binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the file to import data from.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="highmap_8hpp.html">highmap.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;int&gt;</a>   <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a> = {512, 256};</div>
<div class="line">  <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;float&gt;</a> res = {4.f, 2.f};</div>
<div class="line">  <span class="keywordtype">int</span>               seed = 1;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z1 = <a class="code hl_function" href="namespacehmap.html#a40b948c49a05c14f2d540dc1a6952130">hmap::noise_fbm</a>(<a class="code hl_enumvalue" href="namespacehmap.html#ab8197c4c7a85dacb616fee7a7d0df195a87c6abee9c8e2441859223b28e9b4581">hmap::NoiseType::PERLIN</a>, <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>, res, seed);</div>
<div class="line"> </div>
<div class="line">  z1.<a class="code hl_function" href="classhmap_1_1Array.html#a35ce8d4088ce4ae21003df18c204b7c6">to_numpy</a>(<span class="stringliteral">&quot;out.npy&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z2;</div>
<div class="line">  z2.<a class="code hl_function" href="classhmap_1_1Array.html#a61b4eb10e50548b12cfd0cb2f9eddde1">from_numpy</a>(<span class="stringliteral">&quot;out.npy&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacehmap.html#a1c490f296571a75e35d05b10c075ae6c">hmap::export_banner_png</a>(<span class="stringliteral">&quot;ex_from_numpy.png&quot;</span>, {z1, z2}, <a class="code hl_enumvalue" href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369afd0b9cd53cbae62c25ef686ba527d143">hmap::Cmap::INFERNO</a>);</div>
<div class="line">}</div>
<div class="ttc" id="aclasshmap_1_1Array_html_a35ce8d4088ce4ae21003df18c204b7c6"><div class="ttname"><a href="classhmap_1_1Array.html#a35ce8d4088ce4ae21003df18c204b7c6">hmap::Array::to_numpy</a></div><div class="ttdeci">void to_numpy(const std::string &amp;fname) const</div><div class="ttdoc">Export the array to a numpy binary file.</div><div class="ttdef"><b>Definition</b> io.cpp:112</div></div>
<div class="ttc" id="aclasshmap_1_1Array_html_a61b4eb10e50548b12cfd0cb2f9eddde1"><div class="ttname"><a href="classhmap_1_1Array.html#a61b4eb10e50548b12cfd0cb2f9eddde1">hmap::Array::from_numpy</a></div><div class="ttdeci">void from_numpy(const std::string &amp;fname)</div><div class="ttdoc">Import array data from a numpy binary file.</div><div class="ttdef"><b>Definition</b> io.cpp:29</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1bc074aa8ae60f52c105702637631e62" name="a1bc074aa8ae60f52c105702637631e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc074aa8ae60f52c105702637631e62">&#9670;&#160;</a></span>get_gradient_x_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hmap::Array::get_gradient_x_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the gradient in the 'x' (or 'i') direction at a specified index (i, j) using a 2nd order central difference scheme. </p>
<pre class="fragment">   This function computes the gradient in the x-direction, which
</pre><p> measures the rate of change along the x-axis. Note that this function cannot be used at the borders of the data, as the central difference scheme requires values from both sides of the point of interest.</p>
<dl class="section warning"><dt>Warning</dt><dd>The gradient cannot be computed at the borders of the data array. Specifically, the function is not defined for i = 0, j = 0, i = shape.x - 1, or j = shape.y - 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index along the x-direction, expected to be in the range [1, shape.x - 2]. </td></tr>
    <tr><td class="paramname">j</td><td>Index along the y-direction, expected to be in the range [1, shape.y - 2]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float The computed gradient value in the x-direction at the specified index. </dd></dl>

</div>
</div>
<a id="acbe5c386af495d4648cdfa140f098398" name="acbe5c386af495d4648cdfa140f098398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe5c386af495d4648cdfa140f098398">&#9670;&#160;</a></span>get_gradient_y_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hmap::Array::get_gradient_y_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the gradient in the 'y' (or 'j') direction at a specified index (i, j) using a 2nd order central difference scheme. </p>
<pre class="fragment">   This function computes the gradient in the y-direction, which
</pre><p> measures the rate of change along the y-axis. Note that this function cannot be used at the borders of the data, as the central difference scheme requires values from both sides of the point of interest.</p>
<dl class="section warning"><dt>Warning</dt><dd>The gradient cannot be computed at the borders of the data array. Specifically, the function is not defined for i = 0, j = 0, i = shape.x - 1, or j = shape.y - 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index along the x-direction, expected to be in the range [1, shape.x - 2]. </td></tr>
    <tr><td class="paramname">j</td><td>Index along the y-direction, expected to be in the range [1, shape.y - 2]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float The computed gradient value in the y-direction at the specified index. </dd></dl>

</div>
</div>
<a id="a80c3088214a250b00d9e9649266e30d2" name="a80c3088214a250b00d9e9649266e30d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c3088214a250b00d9e9649266e30d2">&#9670;&#160;</a></span>get_gradient_x_bilinear_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hmap::Array::get_gradient_x_bilinear_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the gradient in the 'x' (or 'i') direction at a location (x, y) near the index (i, j) using bilinear interpolation. </p>
<pre class="fragment">   This function uses bilinear interpolation to estimate the gradient
</pre><p> in the x-direction at a point within the cell defined by (i, j). The gradient is based on a 2nd order central difference scheme but interpolated to a finer resolution.</p>
<dl class="section warning"><dt>Warning</dt><dd>The gradient cannot be computed at the borders of the data array. Specifically, the function is not defined for i = 0, j = 0, i = shape.x - 1, or j = shape.y - 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index along the x-direction, expected to be in the range [1, shape.x - 2]. </td></tr>
    <tr><td class="paramname">j</td><td>Index along the y-direction, expected to be in the range [1, shape.y - 2]. </td></tr>
    <tr><td class="paramname">u</td><td>'u' interpolation parameter, expected to be in the range [0, 1[. </td></tr>
    <tr><td class="paramname">v</td><td>'v' interpolation parameter, expected to be in the range [0, 1[. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float The interpolated gradient value in the x-direction at the specified location. </dd></dl>

</div>
</div>
<a id="a5f8056879200c2cfa85a757e8c87bb3d" name="a5f8056879200c2cfa85a757e8c87bb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8056879200c2cfa85a757e8c87bb3d">&#9670;&#160;</a></span>get_gradient_y_bilinear_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hmap::Array::get_gradient_y_bilinear_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the gradient in the 'y' (or 'j') direction at a location (x, y) near the index (i, j) using bilinear interpolation. </p>
<pre class="fragment">   This function uses bilinear interpolation to estimate the gradient
</pre><p> in the y-direction at a point within the cell defined by (i, j). The gradient is based on a 2nd order central difference scheme but interpolated to a finer resolution.</p>
<dl class="section warning"><dt>Warning</dt><dd>The gradient cannot be computed at the borders of the data array. Specifically, the function is not defined for i = 0, j = 0, i = shape.x - 1, or j = shape.y - 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index along the x-direction, expected to be in the range [1, shape.x - 2]. </td></tr>
    <tr><td class="paramname">j</td><td>Index along the y-direction, expected to be in the range [1, shape.y - 2]. </td></tr>
    <tr><td class="paramname">u</td><td>'u' interpolation parameter, expected to be in the range [0, 1[. </td></tr>
    <tr><td class="paramname">v</td><td>'v' interpolation parameter, expected to be in the range [0, 1[. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float The interpolated gradient value in the y-direction at the specified location. </dd></dl>

</div>
</div>
<a id="a0e69d113a5b86b59e2bbf956262a2331" name="a0e69d113a5b86b59e2bbf956262a2331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e69d113a5b86b59e2bbf956262a2331">&#9670;&#160;</a></span>get_normal_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhmap_1_1Vec3.html">Vec3</a>&lt; float &gt; hmap::Array::get_normal_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the surface normal vector at the index (i, j). </p>
<pre class="fragment">   This function computes the surface normal at the specified index (i,
</pre><p> j) in the data array. The normal vector is a three-dimensional vector (x, y, z) that is perpendicular to the surface at that point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index along the x-direction. </td></tr>
    <tr><td class="paramname">j</td><td>Index along the y-direction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vec3&lt;float&gt; The normal vector at the specified index (i, j). </dd></dl>

</div>
</div>
<a id="ad1496c702975e9425113eb4a1dd0e49c" name="ad1496c702975e9425113eb4a1dd0e49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1496c702975e9425113eb4a1dd0e49c">&#9670;&#160;</a></span>get_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt; hmap::Array::get_shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the shape of the array. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structhmap_1_1Vec2.html">Vec2&lt;int&gt;</a> The shape {ni, nj}. </dd></dl>

</div>
</div>
<a id="a7ef7005c4ca95be75c82bded5165634c" name="a7ef7005c4ca95be75c82bded5165634c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef7005c4ca95be75c82bded5165634c">&#9670;&#160;</a></span>get_sizeof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hmap::Array::get_sizeof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of bytes occupied by the array data. </p>
<pre class="fragment">   This function returns the total size in bytes of the underlying
</pre><p> storage vector that holds the array data. This can be useful for memory management or debugging purposes.</p>
<dl class="section return"><dt>Returns</dt><dd>size_t The size of the array data in bytes. </dd></dl>

</div>
</div>
<a id="ae47cb152f3e887d17160519afd589ee2" name="ae47cb152f3e887d17160519afd589ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47cb152f3e887d17160519afd589ee2">&#9670;&#160;</a></span>get_value_bicubic_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hmap::Array::get_value_bicubic_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the array value at the location (x, y) near the index (i, j) using bicubic interpolation. </p>
<pre class="fragment">   This function uses bicubic interpolation to estimate the value at a
</pre><p> point within the cell defined by (i, j). Bicubic interpolation provides a smoother result compared to bilinear interpolation by taking into account the values of the surrounding 4x4 grid of points, resulting in better accuracy when interpolating in areas with gradients or curves.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function cannot be used at the upper borders of the array, specifically for i = shape.x - 2 or j = shape.y - 2, as bicubic interpolation requires surrounding data points from a 4x4 neighborhood.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index along the x-direction, expected to be in the range [1, shape.x - 3]. </td></tr>
    <tr><td class="paramname">j</td><td>Index along the y-direction, expected to be in the range [1, shape.y - 3]. </td></tr>
    <tr><td class="paramname">u</td><td>'u' interpolation parameter, expected to be in the range [0, 1[. </td></tr>
    <tr><td class="paramname">v</td><td>'v' interpolation parameter, expected to be in the range [0, 1[. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float The interpolated value at the specified location (x, y). </dd></dl>

</div>
</div>
<a id="a12eb51c18154e3e452afe9743636085f" name="a12eb51c18154e3e452afe9743636085f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12eb51c18154e3e452afe9743636085f">&#9670;&#160;</a></span>get_value_bilinear_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hmap::Array::get_value_bilinear_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the array value at the location (x, y) near the index (i, j) using bilinear interpolation. </p>
<pre class="fragment">   This function uses bilinear interpolation to estimate the value at a
</pre><p> point within the cell defined by (i, j). Bilinear interpolation is applied based on the surrounding values to approximate the value at the specified (x, y) location.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function cannot be used at the upper borders of the array, specifically for i = shape.x - 1 or j = shape.y - 1, as bilinear interpolation requires surrounding data points.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Index along the x-direction, expected to be in the range [0, shape.x - 2]. </td></tr>
    <tr><td class="paramname">j</td><td>Index along the y-direction, expected to be in the range [0, shape.y - 2]. </td></tr>
    <tr><td class="paramname">u</td><td>'u' interpolation parameter, expected to be in the range [0, 1[. </td></tr>
    <tr><td class="paramname">v</td><td>'v' interpolation parameter, expected to be in the range [0, 1[. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float The interpolated value at the specified location (x, y). </dd></dl>

</div>
</div>
<a id="a9dd25996fe72213935f736f9fdb2c4d4" name="a9dd25996fe72213935f736f9fdb2c4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd25996fe72213935f736f9fdb2c4d4">&#9670;&#160;</a></span>get_value_nearest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hmap::Array::get_value_nearest </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhmap_1_1Vec4.html">Vec4</a>&lt; float &gt;&#160;</td>
          <td class="paramname"><em>bbox</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the nearest value at the location (x, y) within a bounded domain. </p>
<pre class="fragment">   This function retrieves the nearest value to the specified (x, y)
</pre><p> coordinates from the array, assuming the array covers a domain defined by the bounding box <code>bbox</code>. If the coordinates (x, y) are outside the domain, they are clamped to the nearest valid position within the bounding box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Coordinate along the x-axis. </td></tr>
    <tr><td class="paramname">y</td><td>Coordinate along the y-axis. </td></tr>
    <tr><td class="paramname">bbox</td><td>Bounding box defining the domain of the array. It is expected to be in the form of {xmin, xmax, ymin, ymax}. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float The nearest value at the clamped location (x, y). </dd></dl>

</div>
</div>
<a id="a65336e3091ee64a91b3ecce8c01c837b" name="a65336e3091ee64a91b3ecce8c01c837b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65336e3091ee64a91b3ecce8c01c837b">&#9670;&#160;</a></span>get_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; hmap::Array::get_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the underlying data vector. </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;float&gt; The vector containing the array's data. </dd></dl>

</div>
</div>
<a id="a3517b483a468873cefa73f7773a893ec" name="a3517b483a468873cefa73f7773a893ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3517b483a468873cefa73f7773a893ec">&#9670;&#160;</a></span>infos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::infos </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>msg</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display various information about the array. </p>
<pre class="fragment">   This function outputs details about the array, such as its
</pre><p> dimensions, data type, and any other relevant information. The optional <code>msg</code> parameter can be used to include a custom message in the output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Optional message to include in the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a296cad1c7a3fd75b30a39a628bc7bcbe" name="a296cad1c7a3fd75b30a39a628bc7bcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296cad1c7a3fd75b30a39a628bc7bcbe">&#9670;&#160;</a></span>linear_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hmap::Array::linear_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the linear index corresponding to the (i, j) cell in a 2D array. </p>
<pre class="fragment">   This function calculates the linear index for a cell specified by
</pre><p> the (i, j) coordinates in a 2D array. The linear index is useful for accessing elements in a flattened or 1D representation of the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The 'i' index (row index). </td></tr>
    <tr><td class="paramname">j</td><td>The 'j' index (column index). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The linear index corresponding to the (i, j) cell. </dd></dl>

</div>
</div>
<a id="a1d9dda44818ef1fbd4228f42267cc305" name="a1d9dda44818ef1fbd4228f42267cc305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9dda44818ef1fbd4228f42267cc305">&#9670;&#160;</a></span>linear_index_reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt; hmap::Array::linear_index_reverse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a linear index to its corresponding (i, j) cell coordinates. </p>
<pre class="fragment">   This function calculates the 2D cell coordinates (i, j) in the array
</pre><p> from a given linear index <code>k</code>. This is useful for mapping between the 1D and 2D representations of the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>The linear index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structhmap_1_1Vec2.html">Vec2&lt;int&gt;</a> The (i, j) coordinates corresponding to the linear index <code>k</code>. </dd></dl>

</div>
</div>
<a id="a68aac609ccba8f581da1cdf5cee671b9" name="a68aac609ccba8f581da1cdf5cee671b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68aac609ccba8f581da1cdf5cee671b9">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hmap::Array::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of the greatest element in the array. </p>
<pre class="fragment">   This function computes the maximum value present in the array. If
</pre><p> the array is empty, the behavior of this function is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>float The maximum value in the array. </dd></dl>

</div>
</div>
<a id="a1d0c6960def9d61ed748ee6a787421a5" name="a1d0c6960def9d61ed748ee6a787421a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0c6960def9d61ed748ee6a787421a5">&#9670;&#160;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hmap::Array::mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the mean value of the elements in the array. </p>
<pre class="fragment">   This function calculates the average value of all elements in the
</pre><p> array. If the array is empty, the behavior of this function is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>float The mean value of the elements in the array. </dd></dl>

</div>
</div>
<a id="a56c77f78e4864f5c6f2cbd6de8100556" name="a56c77f78e4864f5c6f2cbd6de8100556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c77f78e4864f5c6f2cbd6de8100556">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hmap::Array::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the value of the smallest element in the array. </p>
<pre class="fragment">   This function computes the minimum value present in the array. If
</pre><p> the array is empty, the behavior of this function is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>float The minimum value in the array. </dd></dl>

</div>
</div>
<a id="ab55ee6021288a467f7d782b09e888f25" name="ab55ee6021288a467f7d782b09e888f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55ee6021288a467f7d782b09e888f25">&#9670;&#160;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize array values so that the sum of all elements is equal to 1. </p>
<pre class="fragment">   This function adjusts the values in the array so that their total
</pre><p> sum is normalized to 1. This is often used in scenarios where the array represents a probability distribution. </p>

</div>
</div>
<a id="a7bf76abbc7ad183514f41f2b54a0ad2e" name="a7bf76abbc7ad183514f41f2b54a0ad2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf76abbc7ad183514f41f2b54a0ad2e">&#9670;&#160;</a></span>normalization_coeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; float &gt; hmap::Array::normalization_coeff </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vmin</em> = <code>0.<a class="el" href="distance__transform_8cpp.html#abcb9259cf91bfd25e92a72cdf18c285e">f</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>vmax</em> = <code>1.<a class="el" href="distance__transform_8cpp.html#abcb9259cf91bfd25e92a72cdf18c285e">f</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes normalization coefficients (a, b) such that a * array + b maps the values to the range [vmin, vmax]. </p>
<pre class="fragment">   This function calculates the coefficients used to normalize the
</pre><p> array values so that they fit within the specified range [vmin, vmax]. The normalization is performed using the linear transformation: <code>a * array + b</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmin</td><td>Lower bound of the desired range. </td></tr>
    <tr><td class="paramname">vmax</td><td>Upper bound of the desired range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structhmap_1_1Vec2.html">Vec2&lt;float&gt;</a> Normalization coefficients (a, b) where <code>a</code> scales the values and <code>b</code> shifts them. </dd></dl>

</div>
</div>
<a id="a7ce20e5537ab2729aac320d0b27b7fa5" name="a7ce20e5537ab2729aac320d0b27b7fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce20e5537ab2729aac320d0b27b7fa5">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the array values to the standard output (stdout). </p>
<pre class="fragment">   This function prints the contents of the array in a human-readable
</pre><p> format to the standard output. This can be useful for debugging or inspecting the values of the array. </p>

</div>
</div>
<a id="ac33557899eb50bcf964b2e5a2ad8ddcb" name="ac33557899eb50bcf964b2e5a2ad8ddcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33557899eb50bcf964b2e5a2ad8ddcb">&#9670;&#160;</a></span>ptp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hmap::Array::ptp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the peak-to-peak amplitude (i.e., the difference between the maximum and minimum values) of the array values. </p>
<pre class="fragment">   This function calculates the peak-to-peak amplitude of the array,
</pre><p> which is the difference between the maximum and minimum values in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>float The peak-to-peak amplitude of the array values. </dd></dl>

</div>
</div>
<a id="a1c242d119f67209442a0054601939412" name="a1c242d119f67209442a0054601939412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c242d119f67209442a0054601939412">&#9670;&#160;</a></span>resample_to_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::resample_to_shape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>new_shape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a resampled array of shape <code>new_shape</code> using bilinear interpolation. </p>
<pre class="fragment">   This function resamples the array to a new shape `new_shape` using
</pre><p> bilinear interpolation. The resampling changes the dimensions of the array while preserving the data's spatial relationships.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_shape</td><td>The target shape for the resampled array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resampled array with the specified <code>new_shape</code>.</dd></dl>
<p><b>Example</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="highmap_8hpp.html">highmap.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;int&gt;</a>   <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a> = {256, 256};</div>
<div class="line">  <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;float&gt;</a> res = {4.f, 4.f};</div>
<div class="line">  <span class="keywordtype">int</span>               seed = 1;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z = <a class="code hl_function" href="namespacehmap.html#a03c0be3a7198eebacefcb208b0cfee99">hmap::noise</a>(<a class="code hl_enumvalue" href="namespacehmap.html#ab8197c4c7a85dacb616fee7a7d0df195a87c6abee9c8e2441859223b28e9b4581">hmap::NoiseType::PERLIN</a>, <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>, res, seed);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> zr = z.<a class="code hl_function" href="classhmap_1_1Array.html#a1c242d119f67209442a0054601939412">resample_to_shape</a>({32, 32});</div>
<div class="line"> </div>
<div class="line">  zr.<a class="code hl_function" href="classhmap_1_1Array.html#a9ff7b2c0be8f2b5dd9fc33085cd647d1">to_png</a>(<span class="stringliteral">&quot;ex_resample_to_shape.png&quot;</span>, <a class="code hl_enumvalue" href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369a0741a9943ed0e5c50042ef82d4d55492">hmap::Cmap::VIRIDIS</a>);</div>
<div class="line">}</div>
<div class="ttc" id="aclasshmap_1_1Array_html_a1c242d119f67209442a0054601939412"><div class="ttname"><a href="classhmap_1_1Array.html#a1c242d119f67209442a0054601939412">hmap::Array::resample_to_shape</a></div><div class="ttdeci">Array resample_to_shape(Vec2&lt; int &gt; new_shape) const</div><div class="ttdoc">Return a resampled array of shape new_shape using bilinear interpolation.</div><div class="ttdef"><b>Definition</b> methods.cpp:282</div></div>
<div class="ttc" id="anamespacehmap_html_a03c0be3a7198eebacefcb208b0cfee99"><div class="ttname"><a href="namespacehmap.html#a03c0be3a7198eebacefcb208b0cfee99">hmap::noise</a></div><div class="ttdeci">Array noise(NoiseType noise_type, Vec2&lt; int &gt; shape, Vec2&lt; float &gt; kw, uint seed, const Array *p_noise_x=nullptr, const Array *p_noise_y=nullptr, const Array *p_stretching=nullptr, Vec4&lt; float &gt; bbox={0.f, 1.f, 0.f, 1.f})</div><div class="ttdoc">Return an array filled with coherence noise.</div><div class="ttdef"><b>Definition</b> noise.cpp:16</div></div>
<div class="ttc" id="anamespacehmap_html_ac70fe3cbb32e0340d5dd3e15cdcf9369a0741a9943ed0e5c50042ef82d4d55492"><div class="ttname"><a href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369a0741a9943ed0e5c50042ef82d4d55492">hmap::VIRIDIS</a></div><div class="ttdeci">@ VIRIDIS</div><div class="ttdef"><b>Definition</b> colormaps.hpp:92</div></div>
</div><!-- fragment --><p><b>Result</b> </p><div class="image">
<img src="ex_resample_to_shape.png" alt=""/>
</div>
 
</div>
</div>
<a id="af36ac8e4689795d2e33b827a7f7b439c" name="af36ac8e4689795d2e33b827a7f7b439c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36ac8e4689795d2e33b827a7f7b439c">&#9670;&#160;</a></span>resample_to_shape_bicubic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::resample_to_shape_bicubic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>new_shape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a resampled array of shape <code>new_shape</code> using bicubic interpolation. </p>
<pre class="fragment">   This function resamples the array to a new shape `new_shape` using
</pre><p> bicubic interpolation. The resampling changes the dimensions of the array while preserving the data's spatial relationships with a higher degree of smoothness compared to bilinear interpolation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_shape</td><td>The target shape for the resampled array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resampled array with the specified <code>new_shape</code>.</dd></dl>
<p><b>Example</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="highmap_8hpp.html">highmap.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;int&gt;</a>   <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a> = {256, 256};</div>
<div class="line">  <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;float&gt;</a> res = {4.f, 4.f};</div>
<div class="line">  <span class="keywordtype">int</span>               seed = 1;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z0 = <a class="code hl_function" href="namespacehmap.html#a40b948c49a05c14f2d540dc1a6952130">hmap::noise_fbm</a>(<a class="code hl_enumvalue" href="namespacehmap.html#ab8197c4c7a85dacb616fee7a7d0df195a87c6abee9c8e2441859223b28e9b4581">hmap::NoiseType::PERLIN</a>, <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>, res, seed);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;int&gt;</a> new_shape = {1024, 1024};</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z1 = z0.<a class="code hl_function" href="classhmap_1_1Array.html#a1c242d119f67209442a0054601939412">resample_to_shape</a>(new_shape);</div>
<div class="line">  z1 = z1.<a class="code hl_function" href="classhmap_1_1Array.html#a1c242d119f67209442a0054601939412">resample_to_shape</a>(<a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z2 = z0.<a class="code hl_function" href="classhmap_1_1Array.html#af36ac8e4689795d2e33b827a7f7b439c">resample_to_shape_bicubic</a>(new_shape);</div>
<div class="line">  z2.<a class="code hl_function" href="classhmap_1_1Array.html#a9ff7b2c0be8f2b5dd9fc33085cd647d1">to_png</a>(<span class="stringliteral">&quot;out.png&quot;</span>, <a class="code hl_enumvalue" href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369a65146260717d07e4773aec50520b9ced">hmap::Cmap::JET</a>);</div>
<div class="line">  z2 = z2.<a class="code hl_function" href="classhmap_1_1Array.html#a1c242d119f67209442a0054601939412">resample_to_shape</a>(<a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacehmap.html#a1c490f296571a75e35d05b10c075ae6c">hmap::export_banner_png</a>(<span class="stringliteral">&quot;ex_array_interp.png&quot;</span>,</div>
<div class="line">                          {z0, z1, z2},</div>
<div class="line">                          <a class="code hl_enumvalue" href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369a744ead0b170889e33126895264f1af2c">hmap::Cmap::MAGMA</a>);</div>
<div class="line">}</div>
<div class="ttc" id="aclasshmap_1_1Array_html_af36ac8e4689795d2e33b827a7f7b439c"><div class="ttname"><a href="classhmap_1_1Array.html#af36ac8e4689795d2e33b827a7f7b439c">hmap::Array::resample_to_shape_bicubic</a></div><div class="ttdeci">Array resample_to_shape_bicubic(Vec2&lt; int &gt; new_shape) const</div><div class="ttdoc">Return a resampled array of shape new_shape using bicubic interpolation.</div><div class="ttdef"><b>Definition</b> methods.cpp:287</div></div>
<div class="ttc" id="anamespacehmap_html_ac70fe3cbb32e0340d5dd3e15cdcf9369a744ead0b170889e33126895264f1af2c"><div class="ttname"><a href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369a744ead0b170889e33126895264f1af2c">hmap::MAGMA</a></div><div class="ttdeci">@ MAGMA</div><div class="ttdef"><b>Definition</b> colormaps.hpp:87</div></div>
</div><!-- fragment --><p><b>Result</b> </p><div class="image">
<img src="ex_array_interp.png" alt=""/>
</div>
 
</div>
</div>
<a id="a6f2b1f8bbe8f6e28ebc0cc8616934601" name="a6f2b1f8bbe8f6e28ebc0cc8616934601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2b1f8bbe8f6e28ebc0cc8616934601">&#9670;&#160;</a></span>resample_to_shape_bilinear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::resample_to_shape_bilinear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>new_shape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad438554fd7c3a7d705271e99f91d480c" name="ad438554fd7c3a7d705271e99f91d480c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad438554fd7c3a7d705271e99f91d480c">&#9670;&#160;</a></span>resample_to_shape_nearest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> hmap::Array::resample_to_shape_nearest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>new_shape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a resampled array of shape <code>new_shape</code> using nearest neighbor interpolation. </p>
<pre class="fragment">   This function resamples the array to a new shape `new_shape` using
</pre><p> nearest neighbor interpolation. This method selects the value from the nearest neighbor in the original array, which can be faster but may produce blocky artifacts compared to other interpolation methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_shape</td><td>The target shape for the resampled array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resampled array with the specified <code>new_shape</code>. </dd></dl>

</div>
</div>
<a id="a82d3cc92545cb9ee442d47b4d672750c" name="a82d3cc92545cb9ee442d47b4d672750c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d3cc92545cb9ee442d47b4d672750c">&#9670;&#160;</a></span>row_to_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; hmap::Array::row_to_vector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a row <code>i</code> as a <code>std::vector&lt;float&gt;</code>. </p>
<pre class="fragment">   This function extracts the specified row `i` from the array and
</pre><p> returns it as a <code>std::vector&lt;float&gt;</code>. This is useful for operations where you need to work with individual rows outside of the array structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Row index to extract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;float&gt; The values of the specified row as a vector. </dd></dl>

</div>
</div>
<a id="a8f2e167d01f42e3f953f6ad554c2b49d" name="a8f2e167d01f42e3f953f6ad554c2b49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2e167d01f42e3f953f6ad554c2b49d">&#9670;&#160;</a></span>set_shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::set_shape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>new_shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a new shape for the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_shape</td><td>The new shape of the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11f0e0817bbb740e3350adaca187743e" name="a11f0e0817bbb740e3350adaca187743e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f0e0817bbb740e3350adaca187743e">&#9670;&#160;</a></span>set_slice() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::set_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmap_1_1Vec4.html">Vec4</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a slice defined by indices {i1, i2, j1, j2} to a new value. </p>
<pre class="fragment">   This function updates all elements within the specified slice of the
</pre><p> array to the given <code>value</code>. The slice is defined by the extents {i1, i2, j1, j2}, where <code>i1</code> and <code>i2</code> specify the range for the rows, and <code>j1</code> and <code>j2</code> specify the range for the columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Slice extent indices: {i1, i2, j1, j2}. </td></tr>
    <tr><td class="paramname">value</td><td>The new value to set for the specified slice. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a362927ee451f7546cfd37f0850982ed3" name="a362927ee451f7546cfd37f0850982ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362927ee451f7546cfd37f0850982ed3">&#9670;&#160;</a></span>set_slice() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::set_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhmap_1_1Vec4.html">Vec4</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a16e6671dbf3202dbc86f5eccb0fcb1ad" name="a16e6671dbf3202dbc86f5eccb0fcb1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e6671dbf3202dbc86f5eccb0fcb1ad">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hmap::Array::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the total number of elements in the array. </p>
<pre class="fragment">   This function returns the size of the array, which is the total
</pre><p> number of elements it contains. This can be useful for iterating over the array or for checking its dimensions.</p>
<dl class="section return"><dt>Returns</dt><dd>int The total number of elements in the array. </dd></dl>

</div>
</div>
<a id="aa913be411b57b6a46b45dd3d5ddefcfd" name="aa913be411b57b6a46b45dd3d5ddefcfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa913be411b57b6a46b45dd3d5ddefcfd">&#9670;&#160;</a></span>std()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hmap::Array::std </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the standard deviation of all array values. </p>
<dl class="section return"><dt>Returns</dt><dd>float The standard deviation of all elements in the array. </dd></dl>

</div>
</div>
<a id="a7ee63fb7135276ed8d6643d082f06892" name="a7ee63fb7135276ed8d6643d082f06892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee63fb7135276ed8d6643d082f06892">&#9670;&#160;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hmap::Array::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the sum of all array values. </p>
<pre class="fragment">   This function calculates and returns the sum of all elements in the
</pre><p> array. It can be used to obtain aggregate values or to check the overall magnitude of the array's contents.</p>
<dl class="section return"><dt>Returns</dt><dd>float The sum of all elements in the array. </dd></dl>

</div>
</div>
<a id="abc4875ad6cfe16bd03004ba52f94587c" name="abc4875ad6cfe16bd03004ba52f94587c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4875ad6cfe16bd03004ba52f94587c">&#9670;&#160;</a></span>to_cv_mat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat hmap::Array::to_cv_mat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a 2D <code><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a></code> to an OpenCV <code>cv::Mat</code>. </p>
<p>This function converts a 2D <code><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a></code> object into an OpenCV <code>cv::Mat</code>. The conversion process does not involve copying the data; instead, it uses pointers to the original data in the <code><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a></code>. As a result, any modifications to the <code><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a></code> will directly affect the corresponding <code>cv::Mat</code> and vice versa.</p>
<dl class="section note"><dt>Note</dt><dd>Since this function relies on pointers to the original data, it is crucial for the user to ensure that the <code><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a></code> object remains in scope and valid for the entire lifetime of the <code>cv::Mat</code>. If the <code><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a></code> is destroyed or goes out of scope, the <code>cv::Mat</code> will reference invalid memory, which can lead to undefined behavior.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>cv::Mat</code> object that shares the data with the input <code><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a></code>.</dd></dl>
<p><b>Example</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;opencv2/opencv.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="highmap_8hpp.html">highmap.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;int&gt;</a>   <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a> = {512, 256};</div>
<div class="line">  <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;float&gt;</a> res = {4.f, 2.f};</div>
<div class="line">  <span class="keywordtype">int</span>               seed = 1;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z = <a class="code hl_function" href="namespacehmap.html#a40b948c49a05c14f2d540dc1a6952130">hmap::noise_fbm</a>(<a class="code hl_enumvalue" href="namespacehmap.html#ab8197c4c7a85dacb616fee7a7d0df195a87c6abee9c8e2441859223b28e9b4581">hmap::NoiseType::PERLIN</a>, <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>, res, seed);</div>
<div class="line">  <a class="code hl_function" href="namespacehmap.html#a262e6495cb2d02598f36a2b46114b2b4">hmap::remap</a>(z, 0.f, 1.f);</div>
<div class="line"> </div>
<div class="line">  z.<a class="code hl_function" href="classhmap_1_1Array.html#a9ff7b2c0be8f2b5dd9fc33085cd647d1">to_png</a>(<span class="stringliteral">&quot;out.png&quot;</span>, <a class="code hl_enumvalue" href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369a233f5593cf083495332bafd2607d154d">hmap::Cmap::GRAY</a>);</div>
<div class="line"> </div>
<div class="line">  z.<a class="code hl_function" href="classhmap_1_1Array.html#a3517b483a468873cefa73f7773a893ec">infos</a>();</div>
<div class="line"> </div>
<div class="line">  cv::Mat img = z.<a class="code hl_function" href="classhmap_1_1Array.html#abc4875ad6cfe16bd03004ba52f94587c">to_cv_mat</a>();</div>
<div class="line">  cv::cvtColor(img, img, cv::COLOR_GRAY2BGR);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;int&gt; codec_params = {cv::IMWRITE_EXR_TYPE,</div>
<div class="line">                                   cv::IMWRITE_EXR_TYPE_FLOAT,</div>
<div class="line">                                   cv::IMWRITE_EXR_COMPRESSION,</div>
<div class="line">                                   cv::IMWRITE_EXR_COMPRESSION_NO};</div>
<div class="line"> </div>
<div class="line">  cv::imwrite(<span class="stringliteral">&quot;out.exr&quot;</span>, img, codec_params);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// set compression to cv::IMWRITE_TIFF_COMPRESSION_LZW (apparently</span></div>
<div class="line">  <span class="comment">// not available in openCV public header?)</span></div>
<div class="line">  codec_params = {cv::IMWRITE_TIFF_COMPRESSION, 5};</div>
<div class="line"> </div>
<div class="line">  cv::imwrite(<span class="stringliteral">&quot;out.tiff&quot;</span>, img, codec_params);</div>
<div class="line"> </div>
<div class="line">  img.convertTo(img, CV_16U, 65535);</div>
<div class="line">  cv::imwrite(<span class="stringliteral">&quot;out_cv.png&quot;</span>, img);</div>
<div class="line"> </div>
<div class="line">  cv::imshow(<span class="stringliteral">&quot;example&quot;</span>, img);</div>
<div class="line">  cv::waitKey(0);</div>
<div class="line">}</div>
<div class="ttc" id="aclasshmap_1_1Array_html_a3517b483a468873cefa73f7773a893ec"><div class="ttname"><a href="classhmap_1_1Array.html#a3517b483a468873cefa73f7773a893ec">hmap::Array::infos</a></div><div class="ttdeci">void infos(std::string msg=&quot;&quot;) const</div><div class="ttdoc">Display various information about the array.</div><div class="ttdef"><b>Definition</b> io.cpp:58</div></div>
<div class="ttc" id="aclasshmap_1_1Array_html_abc4875ad6cfe16bd03004ba52f94587c"><div class="ttname"><a href="classhmap_1_1Array.html#abc4875ad6cfe16bd03004ba52f94587c">hmap::Array::to_cv_mat</a></div><div class="ttdeci">cv::Mat to_cv_mat()</div><div class="ttdoc">Converts a 2D Array to an OpenCV cv::Mat.</div><div class="ttdef"><b>Definition</b> opencv_wrapper.cpp:12</div></div>
<div class="ttc" id="anamespacehmap_html_ac70fe3cbb32e0340d5dd3e15cdcf9369a233f5593cf083495332bafd2607d154d"><div class="ttname"><a href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369a233f5593cf083495332bafd2607d154d">hmap::GRAY</a></div><div class="ttdeci">@ GRAY</div><div class="ttdef"><b>Definition</b> colormaps.hpp:83</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa681ff740560464d3830d5f7259282fd" name="aa681ff740560464d3830d5f7259282fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa681ff740560464d3830d5f7259282fd">&#9670;&#160;</a></span>to_exr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::to_exr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the array as an OpenEXR image file. </p>
<pre class="fragment">   This function saves the array data as an OpenEXR image file. OpenEXR
</pre><p> is a high dynamic range (HDR) image file format. The file will be created or overwritten with the name specified by <code>fname</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the OpenEXR file to be created or overwritten.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="a6cd8060670649c0934ddab573e378d3f" name="a6cd8060670649c0934ddab573e378d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd8060670649c0934ddab573e378d3f">&#9670;&#160;</a></span>to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::to_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the array to a raw binary file. </p>
<pre class="fragment">   This function writes the contents of the array to a file in raw
</pre><p> binary format. This can be useful for saving the array data to disk or for transferring it between programs. The file will be created or overwritten with the specified <code>fname</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the file to which the array data will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35ce8d4088ce4ae21003df18c204b7c6" name="a35ce8d4088ce4ae21003df18c204b7c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ce8d4088ce4ae21003df18c204b7c6">&#9670;&#160;</a></span>to_numpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::to_numpy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the array to a numpy binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the file to which the array data will be written.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="highmap_8hpp.html">highmap.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;int&gt;</a>   <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a> = {512, 256};</div>
<div class="line">  <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;float&gt;</a> kw = {4.f, 2.f};</div>
<div class="line">  <span class="keywordtype">int</span>               seed = 1;</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z = <a class="code hl_function" href="namespacehmap.html#a40b948c49a05c14f2d540dc1a6952130">hmap::noise_fbm</a>(<a class="code hl_enumvalue" href="namespacehmap.html#ab8197c4c7a85dacb616fee7a7d0df195a87c6abee9c8e2441859223b28e9b4581">hmap::NoiseType::PERLIN</a>, <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>, kw, seed);</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; z(10, 12) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  z.<a class="code hl_function" href="classhmap_1_1Array.html#a35ce8d4088ce4ae21003df18c204b7c6">to_numpy</a>(<span class="stringliteral">&quot;out.npy&quot;</span>);</div>
<div class="line">  z.<a class="code hl_function" href="classhmap_1_1Array.html#a9ff7b2c0be8f2b5dd9fc33085cd647d1">to_png</a>(<span class="stringliteral">&quot;ex_to_numpy.png&quot;</span>, <a class="code hl_enumvalue" href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369a65146260717d07e4773aec50520b9ced">hmap::Cmap::JET</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// --- python script to check this provided below in the comments</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// import matplotlib.pyplot as plt</span></div>
<div class="line">  <span class="comment">// import numpy as np</span></div>
<div class="line">  <span class="comment">// z = np.load(&#39;out.npy&#39;)</span></div>
<div class="line">  <span class="comment">// print(z.shape)</span></div>
<div class="line">  <span class="comment">// print(z[10, 12])</span></div>
<div class="line">  <span class="comment">// plt.imshow(z, cmap=&#39;jet&#39;)</span></div>
<div class="line">  <span class="comment">// plt.show()</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9ff7b2c0be8f2b5dd9fc33085cd647d1" name="a9ff7b2c0be8f2b5dd9fc33085cd647d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff7b2c0be8f2b5dd9fc33085cd647d1">&#9670;&#160;</a></span>to_png()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::to_png </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hillshading</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>CV_8U</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the array as a PNG image file with a specified colormap and hillshading. </p>
<pre class="fragment">   This function saves the array data as a PNG image file. The colors
</pre><p> of the image are determined by the specified colormap (<code>cmap</code>), and optional hillshading can be applied to enhance the visual representation of the data. The file will be created or overwritten with the name specified by <code>fname</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the PNG file to be created or overwritten. </td></tr>
    <tr><td class="paramname">cmap</td><td>The colormap to be used for visualizing the data. Refer to <code>cmap</code> for available options. </td></tr>
    <tr><td class="paramname">hillshading</td><td>Boolean flag to enable or disable hillshading. If true, hillshading will be applied.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="highmap_8hpp.html">highmap.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;int&gt;</a>   <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a> = {512, 512};</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;float&gt;</a> res = {4.f, 4.f};</div>
<div class="line">  <span class="keywordtype">int</span>                     seed = 2;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// write png</span></div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z1 = <a class="code hl_function" href="namespacehmap.html#a40b948c49a05c14f2d540dc1a6952130">hmap::noise_fbm</a>(<a class="code hl_enumvalue" href="namespacehmap.html#ab8197c4c7a85dacb616fee7a7d0df195a87c6abee9c8e2441859223b28e9b4581">hmap::NoiseType::PERLIN</a>,</div>
<div class="line">                                   <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>,</div>
<div class="line">                                   res,</div>
<div class="line">                                   seed,</div>
<div class="line">                                   8);</div>
<div class="line">  <a class="code hl_function" href="namespacehmap.html#a262e6495cb2d02598f36a2b46114b2b4">hmap::remap</a>(z1);</div>
<div class="line">  z1.<a class="code hl_function" href="classhmap_1_1Array.html#a9ff7b2c0be8f2b5dd9fc33085cd647d1">to_png</a>(<span class="stringliteral">&quot;out_rgb.png&quot;</span>, <a class="code hl_enumvalue" href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369a65146260717d07e4773aec50520b9ced">hmap::Cmap::JET</a>);</div>
<div class="line">  z1.<a class="code hl_function" href="classhmap_1_1Array.html#ad7018857827d8e8d263516bbbd77630f">to_png_grayscale</a>(<span class="stringliteral">&quot;out_8bit.png&quot;</span>);</div>
<div class="line">  z1.<a class="code hl_function" href="classhmap_1_1Array.html#ad7018857827d8e8d263516bbbd77630f">to_png_grayscale</a>(<span class="stringliteral">&quot;out_16bit.png&quot;</span>, CV_16U);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create Array from png</span></div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z2 = <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a>(<span class="stringliteral">&quot;out_8bit.png&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z3 = <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a>(<span class="stringliteral">&quot;out_16bit.png&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  z1.<a class="code hl_function" href="classhmap_1_1Array.html#abc72128c4c460e993d877cab54e17454">to_raw_16bit</a>(<span class="stringliteral">&quot;out.raw&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacehmap.html#a1c490f296571a75e35d05b10c075ae6c">hmap::export_banner_png</a>(<span class="stringliteral">&quot;ex_to_png.png&quot;</span>, {z1, z2, z3}, <a class="code hl_enumvalue" href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369afd0b9cd53cbae62c25ef686ba527d143">hmap::Cmap::INFERNO</a>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad7018857827d8e8d263516bbbd77630f" name="ad7018857827d8e8d263516bbbd77630f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7018857827d8e8d263516bbbd77630f">&#9670;&#160;</a></span>to_png_grayscale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::to_png_grayscale </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em> = <code>CV_8U</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the array as a grayscale PNG image file with specified bit depth. </p>
<p>This function saves the array data as a grayscale PNG image file. The bit depth of the image is determined by the <code>depth</code> parameter, allowing for either 8-bit (0-255) or 16-bit (0-65535) grayscale values. The resulting image will be created or overwritten with the name specified by <code>fname</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the PNG file to be created or overwritten. </td></tr>
    <tr><td class="paramname">depth</td><td>The bit depth of the PNG image. Default is 8-bit (CV_8U). Use CV_16U for 16-bit depth if higher precision is needed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="highmap_8hpp.html">highmap.hpp</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;int&gt;</a>   <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a> = {512, 512};</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_struct" href="structhmap_1_1Vec2.html">hmap::Vec2&lt;float&gt;</a> res = {4.f, 4.f};</div>
<div class="line">  <span class="keywordtype">int</span>                     seed = 2;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// write png</span></div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z1 = <a class="code hl_function" href="namespacehmap.html#a40b948c49a05c14f2d540dc1a6952130">hmap::noise_fbm</a>(<a class="code hl_enumvalue" href="namespacehmap.html#ab8197c4c7a85dacb616fee7a7d0df195a87c6abee9c8e2441859223b28e9b4581">hmap::NoiseType::PERLIN</a>,</div>
<div class="line">                                   <a class="code hl_variable" href="classhmap_1_1Array.html#a3cf6ada373f8af1affcbbed22db1194f">shape</a>,</div>
<div class="line">                                   res,</div>
<div class="line">                                   seed,</div>
<div class="line">                                   8);</div>
<div class="line">  <a class="code hl_function" href="namespacehmap.html#a262e6495cb2d02598f36a2b46114b2b4">hmap::remap</a>(z1);</div>
<div class="line">  z1.<a class="code hl_function" href="classhmap_1_1Array.html#a9ff7b2c0be8f2b5dd9fc33085cd647d1">to_png</a>(<span class="stringliteral">&quot;out_rgb.png&quot;</span>, <a class="code hl_enumvalue" href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369a65146260717d07e4773aec50520b9ced">hmap::Cmap::JET</a>);</div>
<div class="line">  z1.<a class="code hl_function" href="classhmap_1_1Array.html#ad7018857827d8e8d263516bbbd77630f">to_png_grayscale</a>(<span class="stringliteral">&quot;out_8bit.png&quot;</span>);</div>
<div class="line">  z1.<a class="code hl_function" href="classhmap_1_1Array.html#ad7018857827d8e8d263516bbbd77630f">to_png_grayscale</a>(<span class="stringliteral">&quot;out_16bit.png&quot;</span>, CV_16U);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// create Array from png</span></div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z2 = <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a>(<span class="stringliteral">&quot;out_8bit.png&quot;</span>);</div>
<div class="line">  <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a> z3 = <a class="code hl_class" href="classhmap_1_1Array.html">hmap::Array</a>(<span class="stringliteral">&quot;out_16bit.png&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  z1.<a class="code hl_function" href="classhmap_1_1Array.html#abc72128c4c460e993d877cab54e17454">to_raw_16bit</a>(<span class="stringliteral">&quot;out.raw&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="namespacehmap.html#a1c490f296571a75e35d05b10c075ae6c">hmap::export_banner_png</a>(<span class="stringliteral">&quot;ex_to_png.png&quot;</span>, {z1, z2, z3}, <a class="code hl_enumvalue" href="namespacehmap.html#ac70fe3cbb32e0340d5dd3e15cdcf9369afd0b9cd53cbae62c25ef686ba527d143">hmap::Cmap::INFERNO</a>);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a75da0609f64b9410741d198330dde33b" name="a75da0609f64b9410741d198330dde33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75da0609f64b9410741d198330dde33b">&#9670;&#160;</a></span>to_tiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::to_tiff </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the array as a TIFF image file. </p>
<pre class="fragment">   This function saves the array data as a TIFF (Tagged Image File
</pre><p> Format) image file. The file will be created or overwritten with the name specified by <code>fname</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the TIFF file to be created or overwritten.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="abc72128c4c460e993d877cab54e17454" name="abc72128c4c460e993d877cab54e17454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc72128c4c460e993d877cab54e17454">&#9670;&#160;</a></span>to_raw_16bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hmap::Array::to_raw_16bit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export the array as a 16-bit raw file for Unity terrain import. </p>
<pre class="fragment">   This function saves the array data as a raw binary file with 16-bit
</pre><p> depth. The resulting file is suitable for use with Unity terrain import formats. The file will be created or overwritten with the name specified by <code>fname</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The name of the raw file to be created or overwritten.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example</b> </p><div class="fragment"></div><!-- fragment --> 
</div>
</div>
<a id="acc4ea8fbdc162b16a2b0c8de575ff569" name="acc4ea8fbdc162b16a2b0c8de575ff569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4ea8fbdc162b16a2b0c8de575ff569">&#9670;&#160;</a></span>unique_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; hmap::Array::unique_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the unique elements of the array. </p>
<pre class="fragment">   This function extracts and returns a vector containing all unique
</pre><p> values present in the array. The values are sorted in ascending order.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;float&gt; A vector of unique values found in the array. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a58ffc99dbcc9c7e8c0dc186202635a4f" name="a58ffc99dbcc9c7e8c0dc186202635a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ffc99dbcc9c7e8c0dc186202635a4f">&#9670;&#160;</a></span>operator*</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the multiplication operator for scalar multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar value to multiply. </td></tr>
    <tr><td class="paramname">array</td><td>The <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> to multiply with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resulting <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> after multiplication. </dd></dl>

</div>
</div>
<a id="aaf0bbf93f6dba016b681ac09274b5c66" name="aaf0bbf93f6dba016b681ac09274b5c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0bbf93f6dba016b681ac09274b5c66">&#9670;&#160;</a></span>operator/</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the division operator for scalar division. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar value to divide by. </td></tr>
    <tr><td class="paramname">array</td><td>The <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resulting <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> after division. </dd></dl>

</div>
</div>
<a id="a3286ad1492734bca2ad2412b833c65f1" name="a3286ad1492734bca2ad2412b833c65f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3286ad1492734bca2ad2412b833c65f1">&#9670;&#160;</a></span>operator+</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhmap_1_1Array.html">Array</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the addition operator for scalar addition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar value to add. </td></tr>
    <tr><td class="paramname">array</td><td>The <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resulting <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> after addition. </dd></dl>

</div>
</div>
<a id="a3db4ef63385d15069d4ee57c80906d5d" name="a3db4ef63385d15069d4ee57c80906d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db4ef63385d15069d4ee57c80906d5d">&#9670;&#160;</a></span>operator-</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhmap_1_1Array.html">Array</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhmap_1_1Array.html">Array</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloads the subtraction operator for scalar subtraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar value to subtract. </td></tr>
    <tr><td class="paramname">array</td><td>The <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> to subtract from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> The resulting <a class="el" href="classhmap_1_1Array.html" title="Array class, helper to manipulate 2D float array with &quot;(i, j)&quot; indexing.">Array</a> after subtraction. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3cf6ada373f8af1affcbbed22db1194f" name="a3cf6ada373f8af1affcbbed22db1194f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf6ada373f8af1affcbbed22db1194f">&#9670;&#160;</a></span>shape</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhmap_1_1Vec2.html">Vec2</a>&lt;int&gt; hmap::Array::shape</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The shape of the array {ni, nj}. </p>

</div>
</div>
<a id="af586ddce153ac93df48a6d26609d7264" name="af586ddce153ac93df48a6d26609d7264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af586ddce153ac93df48a6d26609d7264">&#9670;&#160;</a></span>vector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; hmap::Array::vector</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The underlying data storage, a vector of size shape.x * shape.y. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>HighMap/include/highmap/<a class="el" href="array_8hpp_source.html">array.hpp</a></li>
<li>HighMap/src/array/<a class="el" href="array_8cpp.html">array.cpp</a></li>
<li>HighMap/src/array/<a class="el" href="io_8cpp.html">io.cpp</a></li>
<li>HighMap/src/array/<a class="el" href="methods_8cpp.html">methods.cpp</a></li>
<li>HighMap/src/array/<a class="el" href="opencv__wrapper_8cpp.html">opencv_wrapper.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehmap.html">hmap</a></li><li class="navelem"><a class="el" href="classhmap_1_1Array.html">Array</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
