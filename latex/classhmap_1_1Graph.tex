\doxysection{hmap\+::Graph Class Reference}
\hypertarget{classhmap_1_1Graph}{}\label{classhmap_1_1Graph}\index{hmap::Graph@{hmap::Graph}}


\doxylink{classhmap_1_1Graph}{Graph} class, to manipulate graphs in 2D.  




{\ttfamily \#include $<$graph.\+hpp$>$}



Inheritance diagram for hmap\+::Graph\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=160pt]{classhmap_1_1Graph__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for hmap\+::Graph\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classhmap_1_1Graph__coll__graph}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classhmap_1_1Graph_a1209ddaafbb68fed3c43ec7766d8dc0a}{Graph}} ()
\begin{DoxyCompactList}\small\item\em Construct a new \doxylink{classhmap_1_1Graph}{Graph} object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhmap_1_1Graph_af7cd4377270d4e0dd90e7c8793351191}{Graph}} (\mbox{\hyperlink{classhmap_1_1Cloud}{Cloud}} cloud)
\begin{DoxyCompactList}\small\item\em Construct a new \doxylink{classhmap_1_1Graph}{Graph} object based on a cloud of points. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhmap_1_1Graph_a0ff744b8d48139b49e7dae7c7d4e7a18}{Graph}} (std\+::vector$<$ \mbox{\hyperlink{classhmap_1_1Point}{Point}} $>$ \mbox{\hyperlink{classhmap_1_1Cloud_aad75fb7bcfa7a2c3f139d2e3d3d6cc54}{points}})
\begin{DoxyCompactList}\small\item\em Construct a new \doxylink{classhmap_1_1Graph}{Graph} object based on a list of points. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhmap_1_1Graph_a6d56f1e42407c74f2cf097b7a9b05d7b}{Graph}} (std\+::vector$<$ float $>$ x, std\+::vector$<$ float $>$ y)
\begin{DoxyCompactList}\small\item\em Construct a new \doxylink{classhmap_1_1Graph}{Graph} object based on x and y coordinates. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Graph_a1f632d4e9ee628a4dcab783f08e42277}{add\+\_\+edge}} (std\+::vector$<$ int $>$ edge, float weight)
\begin{DoxyCompactList}\small\item\em Add an edge to the graph. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Graph_a91ad513cd4834aa3424e9bbd56d891ac}{add\+\_\+edge}} (std\+::vector$<$ int $>$ edge)
\begin{DoxyCompactList}\small\item\em Add an edge to the graph with default weight. \end{DoxyCompactList}\item 
std\+::vector$<$ int $>$ \mbox{\hyperlink{classhmap_1_1Graph_a07e0c31ab59d4f51c51c3f90117ca71a}{dijkstra}} (int source\+\_\+point\+\_\+index, int target\+\_\+point\+\_\+index)
\begin{DoxyCompactList}\small\item\em Return the shortest route between two points using Dijkstra\textquotesingle{}s algorithm. \end{DoxyCompactList}\item 
float \mbox{\hyperlink{classhmap_1_1Graph_aa04970dd704339909bcc4770fa0481ab}{get\+\_\+edge\+\_\+length}} (int k)
\begin{DoxyCompactList}\small\item\em Get the length of edge {\ttfamily k}. \end{DoxyCompactList}\item 
std\+::vector$<$ float $>$ \mbox{\hyperlink{classhmap_1_1Graph_ab9c3f02b3a4921f785eb7f80834ed9d7}{get\+\_\+edge\+\_\+x\+\_\+pairs}} ()
\begin{DoxyCompactList}\small\item\em Return x coordinates of the edges (as pairs). \end{DoxyCompactList}\item 
std\+::vector$<$ float $>$ \mbox{\hyperlink{classhmap_1_1Graph_a0088d1935cc3ee61ede820f51ccf117c}{get\+\_\+edge\+\_\+y\+\_\+pairs}} ()
\begin{DoxyCompactList}\small\item\em Return y coordinates of the edges (as pairs). \end{DoxyCompactList}\item 
std\+::vector$<$ float $>$ \mbox{\hyperlink{classhmap_1_1Graph_abee24a8b157637b7e667531aca13f1c4}{get\+\_\+lengths}} ()
\begin{DoxyCompactList}\small\item\em Get the length of all the edges. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classhmap_1_1Graph_ad110d66385a8e4ef83708914cc972260}{get\+\_\+nedges}} ()
\begin{DoxyCompactList}\small\item\em Get the number of edges in the graph. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhmap_1_1Graph}{Graph}} \mbox{\hyperlink{classhmap_1_1Graph_ad3b05e01d0c31e189fa6bae4ac43de7c}{minimum\+\_\+spanning\+\_\+tree\+\_\+prim}} ()
\begin{DoxyCompactList}\small\item\em Generate a Minimum Spanning Tree (MST) of the graph using Prim\textquotesingle{}s algorithm. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Graph_a862b83b369721a4930917a78bd313421}{print}} ()
\begin{DoxyCompactList}\small\item\em Print the graph data to the standard output. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhmap_1_1Graph}{Graph}} \mbox{\hyperlink{classhmap_1_1Graph_ad1aeb414389af66a30d891d8fc28bc46}{remove\+\_\+orphan\+\_\+points}} ()
\begin{DoxyCompactList}\small\item\em Remove orphan points from the graph. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Graph_ad116684b58ddb292d2af17642b90b40f}{to\+\_\+array}} (\mbox{\hyperlink{classhmap_1_1Array}{Array}} \&array, \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ bbox, bool color\+\_\+by\+\_\+edge\+\_\+weight=true)
\begin{DoxyCompactList}\small\item\em Project the graph to an array and optionally color by edge weight. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Graph_a3a8332f8fc1cc9abaad0096ed3949000}{to\+\_\+array\+\_\+fractalize}} (\mbox{\hyperlink{classhmap_1_1Array}{Array}} \&array, \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ bbox, int iterations, \mbox{\hyperlink{array_8hpp_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} seed, float sigma=0.\+3\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, int orientation=0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, float persistence=1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}})
\begin{DoxyCompactList}\small\item\em Apply fractalization to graph edges and project to an array. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhmap_1_1Array}{Array}} \mbox{\hyperlink{classhmap_1_1Graph_af636b5aa0bfa2c3021f7e33ee282b018}{to\+\_\+array\+\_\+sdf}} (\mbox{\hyperlink{structhmap_1_1Vec2}{Vec2}}$<$ int $>$ shape, \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ bbox, \mbox{\hyperlink{classhmap_1_1Array}{Array}} \texorpdfstring{$\ast$}{*}p\+\_\+noise\+\_\+x=nullptr, \mbox{\hyperlink{classhmap_1_1Array}{Array}} \texorpdfstring{$\ast$}{*}p\+\_\+noise\+\_\+y=nullptr, \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ bbox\+\_\+array=\{0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}\})
\begin{DoxyCompactList}\small\item\em Generate an array filled with the Signed Distance \doxylink{classhmap_1_1Function}{Function} (SDF) to the graph. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Graph_a47f4e4792141971443d9dbeb714ae612}{to\+\_\+csv}} (std\+::string fname\+\_\+xy, std\+::string fname\+\_\+adjacency)
\begin{DoxyCompactList}\small\item\em Export graph data to CSV files. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Graph_a9ceef3779f34960009226304494d5f6c}{to\+\_\+png}} (std\+::string fname, \mbox{\hyperlink{structhmap_1_1Vec2}{Vec2}}$<$ int $>$ shape=\{512, 512\})
\begin{DoxyCompactList}\small\item\em Export the graph as a PNG image file. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Graph_a6accdaeaf48a49a3a751f4a83e59df47}{update\+\_\+adjacency\+\_\+matrix}} ()
\begin{DoxyCompactList}\small\item\em Update the adjacency matrix of the graph. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Graph_ad37ed278a791b43779733f7f22187f15}{update\+\_\+connectivity}} ()
\begin{DoxyCompactList}\small\item\em Update the point connectivity information. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classhmap_1_1Cloud}{hmap\+::\+Cloud}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classhmap_1_1Cloud_a710bdb9a8b189d0886682dcc785c0bc5}{Cloud}} ()
\begin{DoxyCompactList}\small\item\em Default constructor for the \doxylink{classhmap_1_1Cloud}{Cloud} class. \end{DoxyCompactList}\item 
virtual \mbox{\hyperlink{classhmap_1_1Cloud_a37e6f8229904ba2b013fbdf25751c6d4}{\texorpdfstring{$\sim$}{\string~}\+Cloud}} ()=default
\item 
\mbox{\hyperlink{classhmap_1_1Cloud_a658dec15f637182f4451df23f52498af}{Cloud}} (int npoints, \mbox{\hyperlink{array_8hpp_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} seed, \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ bbox=\{0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}\})
\begin{DoxyCompactList}\small\item\em Constructs a new \doxylink{classhmap_1_1Cloud}{Cloud} object with random positions and values. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhmap_1_1Cloud_a76ba65d3116849aecbc2a6d90cd4d652}{Cloud}} (const std\+::vector$<$ \mbox{\hyperlink{classhmap_1_1Point}{Point}} $>$ \&\mbox{\hyperlink{classhmap_1_1Cloud_aad75fb7bcfa7a2c3f139d2e3d3d6cc54}{points}})
\begin{DoxyCompactList}\small\item\em Constructs a new \doxylink{classhmap_1_1Cloud}{Cloud} object based on a list of existing points. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhmap_1_1Cloud_a34e33bc454459b077a2384ecaea4ba26}{Cloud}} (const std\+::vector$<$ float $>$ \&x, const std\+::vector$<$ float $>$ \&y, float default\+\_\+value=0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}})
\begin{DoxyCompactList}\small\item\em Constructs a new \doxylink{classhmap_1_1Cloud}{Cloud} object from lists of {\ttfamily x} and {\ttfamily y} coordinates. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhmap_1_1Cloud_a189ddb2d4389ab85c28ad586fbbc4c30}{Cloud}} (const std\+::vector$<$ float $>$ \&x, const std\+::vector$<$ float $>$ \&y, const std\+::vector$<$ float $>$ \&v)
\begin{DoxyCompactList}\small\item\em Constructs a new \doxylink{classhmap_1_1Cloud}{Cloud} object from lists of {\ttfamily x} and {\ttfamily y} coordinates with assigned values. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_ab1149531131111567d9f8760162d90ff}{add\+\_\+point}} (const \mbox{\hyperlink{classhmap_1_1Point}{Point}} \&p)
\begin{DoxyCompactList}\small\item\em Add a new point to the cloud. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_a247e64e1c0e5cb85570c0ec3aed3d774}{clear}} ()
\begin{DoxyCompactList}\small\item\em Clear all data from the cloud. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classhmap_1_1Cloud_a45c0878a8bcc06335e6afeb8c786a3e0}{from\+\_\+csv}} (const std\+::string \&fname)
\begin{DoxyCompactList}\small\item\em Loads point data from a CSV file into the \doxylink{classhmap_1_1Cloud}{Cloud} object. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ \mbox{\hyperlink{classhmap_1_1Cloud_ab0fc0cc8fd56bfe1e553843c192630d9}{get\+\_\+bbox}} () const
\begin{DoxyCompactList}\small\item\em Get the bounding box of the cloud. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhmap_1_1Point}{Point}} \mbox{\hyperlink{classhmap_1_1Cloud_a2f4679015ee69b12c50f60a607388965}{get\+\_\+center}} () const
\begin{DoxyCompactList}\small\item\em Calculates the centroid of a set of points. \end{DoxyCompactList}\item 
std\+::vector$<$ int $>$ \mbox{\hyperlink{classhmap_1_1Cloud_a10f22c402c1e8e4043c01327bca0f9e8}{get\+\_\+convex\+\_\+hull\+\_\+point\+\_\+indices}} () const
\begin{DoxyCompactList}\small\item\em Computes the indices of the points that form the convex hull of a set of points. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{classhmap_1_1Cloud_a4d6feb0c127bcea6566b600444cf103c}{get\+\_\+npoints}} () const
\begin{DoxyCompactList}\small\item\em Get the number of points in the cloud. \end{DoxyCompactList}\item 
std\+::vector$<$ float $>$ \mbox{\hyperlink{classhmap_1_1Cloud_a53cb47401f1e9d027a638f3680c3004d}{get\+\_\+values}} () const
\begin{DoxyCompactList}\small\item\em Get the values assigned to the points in the cloud. \end{DoxyCompactList}\item 
float \mbox{\hyperlink{classhmap_1_1Cloud_abe70a230c2bfecad67112321b3040286}{get\+\_\+values\+\_\+max}} () const
\begin{DoxyCompactList}\small\item\em Get the maximum value among the points in the cloud. \end{DoxyCompactList}\item 
float \mbox{\hyperlink{classhmap_1_1Cloud_a9194835457c70bfa13d0dfa66d964f01}{get\+\_\+values\+\_\+min}} () const
\begin{DoxyCompactList}\small\item\em Get the minimum value among the points in the cloud. \end{DoxyCompactList}\item 
virtual std\+::vector$<$ float $>$ \mbox{\hyperlink{classhmap_1_1Cloud_aab450c9376e44def1d4e4465f0b1b691}{get\+\_\+x}} () const
\begin{DoxyCompactList}\small\item\em Get the {\ttfamily x} coordinates of the points in the cloud. \end{DoxyCompactList}\item 
virtual std\+::vector$<$ float $>$ \mbox{\hyperlink{classhmap_1_1Cloud_ab0c1fe00f5465c5b0b04e3e397bae5d5}{get\+\_\+xy}} () const
\begin{DoxyCompactList}\small\item\em Get the concatenated {\ttfamily x} and {\ttfamily y} coordinates of the points in the cloud. \end{DoxyCompactList}\item 
virtual std\+::vector$<$ float $>$ \mbox{\hyperlink{classhmap_1_1Cloud_abf5f933e3506395b5369cb090119002e}{get\+\_\+y}} () const
\begin{DoxyCompactList}\small\item\em Get the {\ttfamily y} coordinates of the points in the cloud. \end{DoxyCompactList}\item 
std\+::vector$<$ float $>$ \mbox{\hyperlink{classhmap_1_1Cloud_abc74893b061b954d7a112551036fdb17}{interpolate\+\_\+values\+\_\+from\+\_\+array}} (const \mbox{\hyperlink{classhmap_1_1Array}{Array}} \&array, \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ bbox)
\begin{DoxyCompactList}\small\item\em Interpolate values from an array at the points\textquotesingle{} {\ttfamily (x, y)} locations. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_aefea3d749a554df8a23ec38af5acb415}{print}} ()
\begin{DoxyCompactList}\small\item\em Print information about the cloud\textquotesingle{}s points. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_a5b3c241babf8bbf52436013b5e816718}{randomize}} (\mbox{\hyperlink{array_8hpp_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}} seed, \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ bbox=\{0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}\})
\begin{DoxyCompactList}\small\item\em Randomize the positions and values of the cloud points. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_a35d0d2e48f4063bd7b582bd24a132294}{remap\+\_\+values}} (float vmin, float vmax)
\begin{DoxyCompactList}\small\item\em Remap the values of the cloud points to a target range. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_afa8d7286a65d513bdc90c4c05bc42e0f}{remove\+\_\+point}} (int point\+\_\+idx)
\begin{DoxyCompactList}\small\item\em Remove a point from the cloud. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_a604e61fbcbd8cc469ed21501e65f5c7b}{set\+\_\+values}} (const std\+::vector$<$ float $>$ \&new\+\_\+values)
\begin{DoxyCompactList}\small\item\em Set new values for the cloud points. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_a540b582307b8457f38c43d12d899f2bf}{set\+\_\+values}} (float new\+\_\+value)
\begin{DoxyCompactList}\small\item\em Set a single value for all cloud points. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_ac8d31a5787a009175695ff16904e7944}{set\+\_\+values\+\_\+from\+\_\+array}} (const \mbox{\hyperlink{classhmap_1_1Array}{Array}} \&array, const \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ \&bbox=\{0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}\})
\begin{DoxyCompactList}\small\item\em Set the values of the cloud points using values from an underlying array. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_ae21ace9436c536e848cdda8d6ab61ac0}{set\+\_\+values\+\_\+from\+\_\+border\+\_\+distance}} (const \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ \&bbox=\{0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}\})
\begin{DoxyCompactList}\small\item\em Sets point values based on their distance to the bounding box border. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_adf0b7a7c0c7d414e5d01e19be624aa3c}{set\+\_\+values\+\_\+from\+\_\+chull\+\_\+distance}} ()
\begin{DoxyCompactList}\small\item\em Set the values of the cloud points based on the distance to the convex hull of the cloud. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_ad8b2d626436107c4b0e2c9877747375f}{set\+\_\+values\+\_\+from\+\_\+min\+\_\+distance}} ()
\begin{DoxyCompactList}\small\item\em Sets point values based on the distance to their nearest neighbor. Actually returns the squared distance. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_ad83d71a8729a0e4fcce993c0141275ee}{to\+\_\+array}} (\mbox{\hyperlink{classhmap_1_1Array}{Array}} \&array, \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ bbox=\{0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}\}) const
\begin{DoxyCompactList}\small\item\em Project the cloud points onto an array. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhmap_1_1Array}{Array}} \mbox{\hyperlink{classhmap_1_1Cloud_a04dcb02dd2df076553e410dbcceb2c35}{to\+\_\+array\+\_\+sdf}} (\mbox{\hyperlink{structhmap_1_1Vec2}{Vec2}}$<$ int $>$ shape, \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ bbox, \mbox{\hyperlink{classhmap_1_1Array}{Array}} \texorpdfstring{$\ast$}{*}p\+\_\+noise\+\_\+x=nullptr, \mbox{\hyperlink{classhmap_1_1Array}{Array}} \texorpdfstring{$\ast$}{*}p\+\_\+noise\+\_\+y=nullptr, \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ bbox\+\_\+array=\{0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}\}) const
\begin{DoxyCompactList}\small\item\em Generate an array filled with the signed distance function (SDF) to the cloud points. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_a8d03bbce76e09b07ff9e2901c80a06c7}{to\+\_\+array\+\_\+interp}} (\mbox{\hyperlink{classhmap_1_1Array}{Array}} \&array, \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ bbox=\{0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}\}, \mbox{\hyperlink{namespacehmap_a5bfab5d68e822294ff90fde21b85f581}{Interpolation\+Method2D}} interpolation\+\_\+method=\mbox{\hyperlink{namespacehmap_a5bfab5d68e822294ff90fde21b85f581a69ac444964e6a94c448c395c8f82b135}{Interpolation\+Method2\+D\+::\+DELAUNAY}}, \mbox{\hyperlink{classhmap_1_1Array}{Array}} \texorpdfstring{$\ast$}{*}p\+\_\+noise\+\_\+x=nullptr, \mbox{\hyperlink{classhmap_1_1Array}{Array}} \texorpdfstring{$\ast$}{*}p\+\_\+noise\+\_\+y=nullptr, \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ bbox\+\_\+array=\{0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}\}) const
\begin{DoxyCompactList}\small\item\em Interpolate the values of an array using the cloud points. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_aea876ffcd05ba762a9a12d2fc4a5d27c}{to\+\_\+csv}} (const std\+::string \&fname) const
\begin{DoxyCompactList}\small\item\em Export the cloud data to a CSV file. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classhmap_1_1Graph}{Graph}} \mbox{\hyperlink{classhmap_1_1Cloud_add728a8b00dadb4a1d043ce50876c569}{to\+\_\+graph\+\_\+delaunay}} ()
\begin{DoxyCompactList}\small\item\em Convert the cloud to a graph using Delaunay triangulation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classhmap_1_1Cloud_a91285c977568113029ee6864928d6ee2}{to\+\_\+png}} (const std\+::string \&fname, int cmap, \mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$ bbox=\{0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}, 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}\}, int depth=CV\+\_\+8U, \mbox{\hyperlink{structhmap_1_1Vec2}{Vec2}}$<$ int $>$ shape=\{512, 512\})
\begin{DoxyCompactList}\small\item\em Saves the current data as a PNG image file. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \mbox{\hyperlink{classhmap_1_1Graph_ae6a15dbafff50f5aa083c975292acffd}{edges}} = \{\}
\begin{DoxyCompactList}\small\item\em Edges of the graph. \end{DoxyCompactList}\item 
std\+::vector$<$ float $>$ \mbox{\hyperlink{classhmap_1_1Graph_a72f35dca4fd9c5f061bdc6b2ad70cb5e}{weights}} = \{\}
\begin{DoxyCompactList}\small\item\em \doxylink{classhmap_1_1Edge}{Edge} weights. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \mbox{\hyperlink{classhmap_1_1Graph_ac4fa0788cdc6162d9254b059ae9857da}{connectivity}} = \{\}
\begin{DoxyCompactList}\small\item\em Store point connectivity. \end{DoxyCompactList}\item 
std\+::map$<$ std\+::pair$<$ int, int $>$, float $>$ \mbox{\hyperlink{classhmap_1_1Graph_a93e452d7229b47e83f431502a18f68da}{adjacency\+\_\+matrix}}
\begin{DoxyCompactList}\small\item\em Adjacency matrix. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes inherited from \mbox{\hyperlink{classhmap_1_1Cloud}{hmap\+::\+Cloud}}}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ \mbox{\hyperlink{classhmap_1_1Point}{Point}} $>$ \mbox{\hyperlink{classhmap_1_1Cloud_aad75fb7bcfa7a2c3f139d2e3d3d6cc54}{points}} = \{\}
\begin{DoxyCompactList}\small\item\em Points of the cloud. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\doxylink{classhmap_1_1Graph}{Graph} class, to manipulate graphs in 2D. 

This class represents a 2D graph, allowing the creation, manipulation, and analysis of graphs derived from point clouds. It supports operations such as graph construction, traversal, and various geometric analyses. This class inherits from the {\ttfamily \doxylink{classhmap_1_1Cloud}{Cloud}} class, leveraging the functionalities of point clouds while adding graph-\/specific methods.

{\bfseries{Example}} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{highmap_8hpp}{highmap.hpp}}"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main(\textcolor{keywordtype}{void})}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{int}\ seed\ =\ 1;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{structhmap_1_1Vec4}{hmap::Vec4<float>}}\ bbox\ =\ \{-\/1.f,\ 2.f,\ 0.f,\ 5.f\};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ create\ a\ cloud\ of\ points\ and\ convert\ it\ to\ a\ graph\ using\ Delaunay}}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ triangulation}}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{int}\ \ \ \ \ \ \ \ \ npoints\ =\ 10;}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classhmap_1_1Cloud}{hmap::Cloud}}\ cloud\ =\ \mbox{\hyperlink{classhmap_1_1Cloud}{hmap::Cloud}}(npoints,\ seed,\ bbox);}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classhmap_1_1Graph}{hmap::Graph}}\ graph\ =\ cloud.\mbox{\hyperlink{classhmap_1_1Cloud_add728a8b00dadb4a1d043ce50876c569}{to\_graph\_delaunay}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ graph.\mbox{\hyperlink{classhmap_1_1Graph_a862b83b369721a4930917a78bd313421}{print}}();}
\DoxyCodeLine{\ \ graph.\mbox{\hyperlink{classhmap_1_1Graph_a9ceef3779f34960009226304494d5f6c}{to\_png}}(\textcolor{stringliteral}{"{}ex\_graph0.png"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ graph.\mbox{\hyperlink{classhmap_1_1Graph_a6accdaeaf48a49a3a751f4a83e59df47}{update\_adjacency\_matrix}}();}
\DoxyCodeLine{\ \ graph.\mbox{\hyperlink{classhmap_1_1Graph_a47f4e4792141971443d9dbeb714ae612}{to\_csv}}(\textcolor{stringliteral}{"{}ex\_graph\_nodes.csv"{}},\ \textcolor{stringliteral}{"{}ex\_graph\_adj.csv"{}});}
\DoxyCodeLine{\}}

\end{DoxyCodeInclude}


{\bfseries{Result}}  

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classhmap_1_1Graph_a1209ddaafbb68fed3c43ec7766d8dc0a}\label{classhmap_1_1Graph_a1209ddaafbb68fed3c43ec7766d8dc0a} 
\index{hmap::Graph@{hmap::Graph}!Graph@{Graph}}
\index{Graph@{Graph}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{Graph()}{Graph()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily hmap\+::\+Graph\+::\+Graph (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct a new \doxylink{classhmap_1_1Graph}{Graph} object. 

The default constructor initializes a new {\ttfamily \doxylink{classhmap_1_1Graph}{Graph}} object. It calls the base class constructor {\ttfamily \doxylink{classhmap_1_1Cloud_a710bdb9a8b189d0886682dcc785c0bc5}{Cloud()}} to set up any inherited functionality from the {\ttfamily \doxylink{classhmap_1_1Cloud}{Cloud}} class. This constructor sets up an empty graph with no edges, weights, connectivity, or adjacency matrix. \Hypertarget{classhmap_1_1Graph_af7cd4377270d4e0dd90e7c8793351191}\label{classhmap_1_1Graph_af7cd4377270d4e0dd90e7c8793351191} 
\index{hmap::Graph@{hmap::Graph}!Graph@{Graph}}
\index{Graph@{Graph}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{Graph()}{Graph()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily hmap\+::\+Graph\+::\+Graph (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhmap_1_1Cloud}{Cloud}}}]{cloud }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct a new \doxylink{classhmap_1_1Graph}{Graph} object based on a cloud of points. 

This constructor initializes a {\ttfamily \doxylink{classhmap_1_1Graph}{Graph}} object using a {\ttfamily \doxylink{classhmap_1_1Cloud}{Cloud}} object. The {\ttfamily \doxylink{classhmap_1_1Cloud}{Cloud}} object provides the points which will be used to construct the graph. This constructor is useful when you have a {\ttfamily \doxylink{classhmap_1_1Cloud}{Cloud}} object and want to create a {\ttfamily \doxylink{classhmap_1_1Graph}{Graph}} representation from it.


\begin{DoxyParams}{Parameters}
{\em cloud} & The cloud of points used to initialize the graph. \\
\hline
\end{DoxyParams}
\Hypertarget{classhmap_1_1Graph_a0ff744b8d48139b49e7dae7c7d4e7a18}\label{classhmap_1_1Graph_a0ff744b8d48139b49e7dae7c7d4e7a18} 
\index{hmap::Graph@{hmap::Graph}!Graph@{Graph}}
\index{Graph@{Graph}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{Graph()}{Graph()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily hmap\+::\+Graph\+::\+Graph (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{classhmap_1_1Point}{Point}} $>$}]{points }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct a new \doxylink{classhmap_1_1Graph}{Graph} object based on a list of points. 

This constructor initializes a {\ttfamily \doxylink{classhmap_1_1Graph}{Graph}} object using a vector of {\ttfamily \doxylink{classhmap_1_1Point}{Point}} objects. The {\ttfamily \doxylink{classhmap_1_1Point}{Point}} objects are used to populate the vertices of the graph. This constructor is useful when you have a list of {\ttfamily \doxylink{classhmap_1_1Point}{Point}} objects and want to create a {\ttfamily \doxylink{classhmap_1_1Graph}{Graph}} representation from them.


\begin{DoxyParams}{Parameters}
{\em points} & The list of points used to initialize the graph. \\
\hline
\end{DoxyParams}
\Hypertarget{classhmap_1_1Graph_a6d56f1e42407c74f2cf097b7a9b05d7b}\label{classhmap_1_1Graph_a6d56f1e42407c74f2cf097b7a9b05d7b} 
\index{hmap::Graph@{hmap::Graph}!Graph@{Graph}}
\index{Graph@{Graph}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{Graph()}{Graph()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily hmap\+::\+Graph\+::\+Graph (\begin{DoxyParamCaption}\item[{std\+::vector$<$ float $>$}]{x,  }\item[{std\+::vector$<$ float $>$}]{y }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct a new \doxylink{classhmap_1_1Graph}{Graph} object based on x and y coordinates. 

This constructor initializes a {\ttfamily \doxylink{classhmap_1_1Graph}{Graph}} object using separate vectors for x and y coordinates. The points are created from these coordinates and used to populate the vertices of the graph. This constructor is useful when you have x and y coordinates and want to create a {\ttfamily \doxylink{classhmap_1_1Graph}{Graph}} representation from them.


\begin{DoxyParams}{Parameters}
{\em x} & Vector of x coordinates for the points. \\
\hline
{\em y} & Vector of y coordinates for the points. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\Hypertarget{classhmap_1_1Graph_a1f632d4e9ee628a4dcab783f08e42277}\label{classhmap_1_1Graph_a1f632d4e9ee628a4dcab783f08e42277} 
\index{hmap::Graph@{hmap::Graph}!add\_edge@{add\_edge}}
\index{add\_edge@{add\_edge}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{add\_edge()}{add\_edge()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void hmap\+::\+Graph\+::add\+\_\+edge (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$}]{edge,  }\item[{float}]{weight }\end{DoxyParamCaption})}



Add an edge to the graph. 

This method adds a new edge to the graph. The edge is specified by a vector of two indices representing the points connected by the edge. The weight of the edge can be provided explicitly; if not provided, the Euclidean distance between the connected points is used as the default weight.


\begin{DoxyParams}{Parameters}
{\em edge} & A vector of two integers representing the indices of the points connected by the edge. \\
\hline
{\em weight} & The weight of the edge. If not provided, the default weight is calculated as the Euclidean distance between the points. \\
\hline
\end{DoxyParams}
\Hypertarget{classhmap_1_1Graph_a91ad513cd4834aa3424e9bbd56d891ac}\label{classhmap_1_1Graph_a91ad513cd4834aa3424e9bbd56d891ac} 
\index{hmap::Graph@{hmap::Graph}!add\_edge@{add\_edge}}
\index{add\_edge@{add\_edge}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{add\_edge()}{add\_edge()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void hmap\+::\+Graph\+::add\+\_\+edge (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$}]{edge }\end{DoxyParamCaption})}



Add an edge to the graph with default weight. 

This method adds a new edge to the graph. The edge is specified by a vector of two indices representing the points connected by the edge. The weight of the edge is calculated as the Euclidean distance between the connected points.


\begin{DoxyParams}{Parameters}
{\em edge} & A vector of two integers representing the indices of the points connected by the edge. \\
\hline
\end{DoxyParams}
\Hypertarget{classhmap_1_1Graph_a07e0c31ab59d4f51c51c3f90117ca71a}\label{classhmap_1_1Graph_a07e0c31ab59d4f51c51c3f90117ca71a} 
\index{hmap::Graph@{hmap::Graph}!dijkstra@{dijkstra}}
\index{dijkstra@{dijkstra}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{dijkstra()}{dijkstra()}}
{\footnotesize\ttfamily std\+::vector$<$ int $>$ hmap\+::\+Graph\+::dijkstra (\begin{DoxyParamCaption}\item[{int}]{source\+\_\+point\+\_\+index,  }\item[{int}]{target\+\_\+point\+\_\+index }\end{DoxyParamCaption})}



Return the shortest route between two points using Dijkstra\textquotesingle{}s algorithm. 

This method computes the shortest path from a specified source point to a target point in the graph using Dijkstra\textquotesingle{}s algorithm. It returns a vector of point indices representing the route from the source to the target point.


\begin{DoxyParams}{Parameters}
{\em source\+\_\+point\+\_\+index} & The index of the starting point in the graph. \\
\hline
{\em target\+\_\+point\+\_\+index} & The index of the ending point in the graph. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
std\+::vector$<$int$>$ A vector of point indices representing the shortest path from the source to the target.
\end{DoxyReturn}
{\bfseries{Example}} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{highmap_8hpp}{highmap.hpp}}"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main(\textcolor{keywordtype}{void})}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{int}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ seed\ =\ 1;}
\DoxyCodeLine{\ \ \mbox{\hyperlink{structhmap_1_1Vec4}{hmap::Vec4<float>}}\ bbox\ =\ \{-\/1.f,\ 2.f,\ 0.f,\ 5.f\};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ create\ a\ cloud\ of\ points\ and\ convert\ it\ to\ a\ graph\ using\ Delaunay}}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ triangulation}}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{int}\ \ \ \ \ \ \ \ \ npoints\ =\ 15;}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classhmap_1_1Cloud}{hmap::Cloud}}\ cloud\ =\ \mbox{\hyperlink{classhmap_1_1Cloud}{hmap::Cloud}}(npoints,\ seed,\ bbox);}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classhmap_1_1Graph}{hmap::Graph}}\ graph\ =\ cloud.\mbox{\hyperlink{classhmap_1_1Cloud_add728a8b00dadb4a1d043ce50876c569}{to\_graph\_delaunay}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ graph.\mbox{\hyperlink{classhmap_1_1Graph_a862b83b369721a4930917a78bd313421}{print}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ graph.\mbox{\hyperlink{classhmap_1_1Graph_a6accdaeaf48a49a3a751f4a83e59df47}{update\_adjacency\_matrix}}();}
\DoxyCodeLine{\ \ graph.\mbox{\hyperlink{classhmap_1_1Graph_ad37ed278a791b43779733f7f22187f15}{update\_connectivity}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{int}\ \ \ \ \ \ \ \ \ \ \ \ \ \ i\_point\_start\ =\ 0;}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{int}\ \ \ \ \ \ \ \ \ \ \ \ \ \ i\_point\_end\ =\ 4;}
\DoxyCodeLine{\ \ std::vector<int>\ route\ =\ graph.\mbox{\hyperlink{classhmap_1_1Graph_a07e0c31ab59d4f51c51c3f90117ca71a}{dijkstra}}(i\_point\_start,\ i\_point\_end);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ std::cout\ <<\ \textcolor{stringliteral}{"{}Route\ (point\ indices):\(\backslash\)n"{}};}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ \&p\ :\ route)}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ p\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{\}}

\end{DoxyCodeInclude}
 \Hypertarget{classhmap_1_1Graph_aa04970dd704339909bcc4770fa0481ab}\label{classhmap_1_1Graph_aa04970dd704339909bcc4770fa0481ab} 
\index{hmap::Graph@{hmap::Graph}!get\_edge\_length@{get\_edge\_length}}
\index{get\_edge\_length@{get\_edge\_length}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{get\_edge\_length()}{get\_edge\_length()}}
{\footnotesize\ttfamily float hmap\+::\+Graph\+::get\+\_\+edge\+\_\+length (\begin{DoxyParamCaption}\item[{int}]{k }\end{DoxyParamCaption})}



Get the length of edge {\ttfamily k}. 

This method calculates the Euclidean length of a specific edge in the graph. The edge is identified by the index {\ttfamily k}, and its length is determined by the distance between the two vertices connected by the edge.


\begin{DoxyParams}{Parameters}
{\em k} & Index of the edge for which the length is to be computed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
float The Euclidean length of the edge. 
\end{DoxyReturn}
\Hypertarget{classhmap_1_1Graph_ab9c3f02b3a4921f785eb7f80834ed9d7}\label{classhmap_1_1Graph_ab9c3f02b3a4921f785eb7f80834ed9d7} 
\index{hmap::Graph@{hmap::Graph}!get\_edge\_x\_pairs@{get\_edge\_x\_pairs}}
\index{get\_edge\_x\_pairs@{get\_edge\_x\_pairs}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{get\_edge\_x\_pairs()}{get\_edge\_x\_pairs()}}
{\footnotesize\ttfamily std\+::vector$<$ float $>$ hmap\+::\+Graph\+::get\+\_\+edge\+\_\+x\+\_\+pairs (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Return x coordinates of the edges (as pairs). 

This method returns the x coordinates of the endpoints of each edge in the graph. The coordinates are returned as a vector of floats, where each pair of floats represents the x coordinates of an edge\textquotesingle{}s endpoints.

\begin{DoxyReturn}{Returns}
std\+::vector$<$float$>$ The x coordinates of the edges. 
\end{DoxyReturn}
\Hypertarget{classhmap_1_1Graph_a0088d1935cc3ee61ede820f51ccf117c}\label{classhmap_1_1Graph_a0088d1935cc3ee61ede820f51ccf117c} 
\index{hmap::Graph@{hmap::Graph}!get\_edge\_y\_pairs@{get\_edge\_y\_pairs}}
\index{get\_edge\_y\_pairs@{get\_edge\_y\_pairs}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{get\_edge\_y\_pairs()}{get\_edge\_y\_pairs()}}
{\footnotesize\ttfamily std\+::vector$<$ float $>$ hmap\+::\+Graph\+::get\+\_\+edge\+\_\+y\+\_\+pairs (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Return y coordinates of the edges (as pairs). 

This method returns the y coordinates of the endpoints of each edge in the graph. The coordinates are returned as a vector of floats, where each pair of floats represents the y coordinates of an edge\textquotesingle{}s endpoints.

\begin{DoxyReturn}{Returns}
std\+::vector$<$float$>$ The y coordinates of the edges. 
\end{DoxyReturn}
\Hypertarget{classhmap_1_1Graph_abee24a8b157637b7e667531aca13f1c4}\label{classhmap_1_1Graph_abee24a8b157637b7e667531aca13f1c4} 
\index{hmap::Graph@{hmap::Graph}!get\_lengths@{get\_lengths}}
\index{get\_lengths@{get\_lengths}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{get\_lengths()}{get\_lengths()}}
{\footnotesize\ttfamily std\+::vector$<$ float $>$ hmap\+::\+Graph\+::get\+\_\+lengths (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the length of all the edges. 

This method returns the lengths of all the edges in the graph. The lengths are computed using the Euclidean distance formula, and the result is returned as a vector of floats.

\begin{DoxyReturn}{Returns}
std\+::vector$<$float$>$ The lengths of all the edges in the graph. 
\end{DoxyReturn}
\Hypertarget{classhmap_1_1Graph_ad110d66385a8e4ef83708914cc972260}\label{classhmap_1_1Graph_ad110d66385a8e4ef83708914cc972260} 
\index{hmap::Graph@{hmap::Graph}!get\_nedges@{get\_nedges}}
\index{get\_nedges@{get\_nedges}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{get\_nedges()}{get\_nedges()}}
{\footnotesize\ttfamily size\+\_\+t hmap\+::\+Graph\+::get\+\_\+nedges (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the number of edges in the graph. 

This method returns the total number of edges present in the graph. The edges are stored in a vector, and this method returns the size of that vector, which represents the number of edges.

\begin{DoxyReturn}{Returns}
size\+\_\+t The number of edges in the graph. 
\end{DoxyReturn}
\Hypertarget{classhmap_1_1Graph_ad3b05e01d0c31e189fa6bae4ac43de7c}\label{classhmap_1_1Graph_ad3b05e01d0c31e189fa6bae4ac43de7c} 
\index{hmap::Graph@{hmap::Graph}!minimum\_spanning\_tree\_prim@{minimum\_spanning\_tree\_prim}}
\index{minimum\_spanning\_tree\_prim@{minimum\_spanning\_tree\_prim}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{minimum\_spanning\_tree\_prim()}{minimum\_spanning\_tree\_prim()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhmap_1_1Graph}{Graph}} hmap\+::\+Graph\+::minimum\+\_\+spanning\+\_\+tree\+\_\+prim (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Generate a Minimum Spanning Tree (MST) of the graph using Prim\textquotesingle{}s algorithm. 

This method creates a Minimum Spanning Tree from the graph using Prim\textquotesingle{}s algorithm. It returns a new {\ttfamily \doxylink{classhmap_1_1Graph}{Graph}} object that represents the MST, which connects all the points in the graph with the minimum total edge weight.

\begin{DoxyReturn}{Returns}
\doxylink{classhmap_1_1Graph}{Graph} The Minimum Spanning Tree (MST) of the original graph.
\end{DoxyReturn}
{\bfseries{Example}} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{highmap_8hpp}{highmap.hpp}}"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main(\textcolor{keywordtype}{void})}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{int}\ seed\ =\ 1;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{structhmap_1_1Vec4}{hmap::Vec4<float>}}\ bbox\ =\ \{-\/1.f,\ 2.f,\ 0.f,\ 5.f\};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ create\ a\ cloud\ of\ points\ and\ convert\ it\ to\ a\ graph\ using\ Delaunay}}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ triangulation}}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{int}\ \ \ \ \ \ \ \ \ npoints\ =\ 10;}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classhmap_1_1Cloud}{hmap::Cloud}}\ cloud\ =\ \mbox{\hyperlink{classhmap_1_1Cloud}{hmap::Cloud}}(npoints,\ seed,\ bbox);}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classhmap_1_1Graph}{hmap::Graph}}\ graph\_delaunay\ =\ cloud.\mbox{\hyperlink{classhmap_1_1Cloud_add728a8b00dadb4a1d043ce50876c569}{to\_graph\_delaunay}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ graph\_delaunay.\mbox{\hyperlink{classhmap_1_1Graph_a6accdaeaf48a49a3a751f4a83e59df47}{update\_adjacency\_matrix}}();}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classhmap_1_1Graph}{hmap::Graph}}\ graph\_mst\ =\ graph\_delaunay.\mbox{\hyperlink{classhmap_1_1Graph_ad3b05e01d0c31e189fa6bae4ac43de7c}{minimum\_spanning\_tree\_prim}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ graph\_delaunay.\mbox{\hyperlink{classhmap_1_1Graph_a9ceef3779f34960009226304494d5f6c}{to\_png}}(\textcolor{stringliteral}{"{}ex\_graph\_minimum\_spanning\_tree\_prim0.png"{}});}
\DoxyCodeLine{\ \ graph\_mst.\mbox{\hyperlink{classhmap_1_1Graph_a9ceef3779f34960009226304494d5f6c}{to\_png}}(\textcolor{stringliteral}{"{}ex\_graph\_minimum\_spanning\_tree\_prim1.png"{}});}
\DoxyCodeLine{\}}

\end{DoxyCodeInclude}
 Result\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}   \Hypertarget{classhmap_1_1Graph_a862b83b369721a4930917a78bd313421}\label{classhmap_1_1Graph_a862b83b369721a4930917a78bd313421} 
\index{hmap::Graph@{hmap::Graph}!print@{print}}
\index{print@{print}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{print()}{print()}}
{\footnotesize\ttfamily void hmap\+::\+Graph\+::print (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Print the graph data to the standard output. 

This method prints the current state of the graph, including point coordinates, edges, and edge weights. \Hypertarget{classhmap_1_1Graph_ad1aeb414389af66a30d891d8fc28bc46}\label{classhmap_1_1Graph_ad1aeb414389af66a30d891d8fc28bc46} 
\index{hmap::Graph@{hmap::Graph}!remove\_orphan\_points@{remove\_orphan\_points}}
\index{remove\_orphan\_points@{remove\_orphan\_points}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{remove\_orphan\_points()}{remove\_orphan\_points()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhmap_1_1Graph}{Graph}} hmap\+::\+Graph\+::remove\+\_\+orphan\+\_\+points (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Remove orphan points from the graph. 

Orphan points are points that are not connected to any edges. This method removes such points from the graph and returns a new {\ttfamily \doxylink{classhmap_1_1Graph}{Graph}} object that excludes these orphan points.

\begin{DoxyReturn}{Returns}
\doxylink{classhmap_1_1Graph}{Graph} A new graph object with orphan points removed. 
\end{DoxyReturn}
\Hypertarget{classhmap_1_1Graph_ad116684b58ddb292d2af17642b90b40f}\label{classhmap_1_1Graph_ad116684b58ddb292d2af17642b90b40f} 
\index{hmap::Graph@{hmap::Graph}!to\_array@{to\_array}}
\index{to\_array@{to\_array}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{to\_array()}{to\_array()}}
{\footnotesize\ttfamily void hmap\+::\+Graph\+::to\+\_\+array (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhmap_1_1Array}{Array}} \&}]{array,  }\item[{\mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$}]{bbox,  }\item[{bool}]{color\+\_\+by\+\_\+edge\+\_\+weight = {\ttfamily true} }\end{DoxyParamCaption})}



Project the graph to an array and optionally color by edge weight. 

This method projects the graph onto a 2D array. The array\textquotesingle{}s elements are filled based on the graph\textquotesingle{}s structure, and optionally, the color can represent edge weights. This allows visual representation of the graph in array form.


\begin{DoxyParams}{Parameters}
{\em array} & The input array to project the graph onto. \\
\hline
{\em bbox} & The bounding box for the array. \\
\hline
{\em color\+\_\+by\+\_\+edge\+\_\+weight} & If {\ttfamily true}, colors the array based on edge weights; otherwise, colors by node values. \\
\hline
\end{DoxyParams}
\Hypertarget{classhmap_1_1Graph_a3a8332f8fc1cc9abaad0096ed3949000}\label{classhmap_1_1Graph_a3a8332f8fc1cc9abaad0096ed3949000} 
\index{hmap::Graph@{hmap::Graph}!to\_array\_fractalize@{to\_array\_fractalize}}
\index{to\_array\_fractalize@{to\_array\_fractalize}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{to\_array\_fractalize()}{to\_array\_fractalize()}}
{\footnotesize\ttfamily void hmap\+::\+Graph\+::to\+\_\+array\+\_\+fractalize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classhmap_1_1Array}{Array}} \&}]{array,  }\item[{\mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$}]{bbox,  }\item[{int}]{iterations,  }\item[{\mbox{\hyperlink{array_8hpp_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}}]{seed,  }\item[{float}]{sigma = {\ttfamily 0.3\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}},  }\item[{int}]{orientation = {\ttfamily 0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}},  }\item[{float}]{persistence = {\ttfamily 1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}} }\end{DoxyParamCaption})}



Apply fractalization to graph edges and project to an array. 

This method applies a fractalization process to the graph edges, creating a more complex structure, and then projects the result onto an array. The fractalization includes multiple iterations and random Gaussian displacement to generate a fractal effect. The parameters control the number of iterations, randomness, and how the graph path is altered.


\begin{DoxyParams}{Parameters}
{\em array} & The input array to project the fractalized graph onto. \\
\hline
{\em bbox} & The bounding box for the array. \\
\hline
{\em iterations} & Number of fractalization iterations to perform. \\
\hline
{\em seed} & Random seed number for stochastic processes. \\
\hline
{\em sigma} & Half-\/width of the Gaussian displacement normalized by the distance between points. \\
\hline
{\em orientation} & Displacement orientation\+: 0 for random inward/outward, 1 to inflate, -\/1 to deflate. \\
\hline
{\em persistence} & Noise persistence factor with respect to iteration number. \\
\hline
\end{DoxyParams}
\Hypertarget{classhmap_1_1Graph_af636b5aa0bfa2c3021f7e33ee282b018}\label{classhmap_1_1Graph_af636b5aa0bfa2c3021f7e33ee282b018} 
\index{hmap::Graph@{hmap::Graph}!to\_array\_sdf@{to\_array\_sdf}}
\index{to\_array\_sdf@{to\_array\_sdf}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{to\_array\_sdf()}{to\_array\_sdf()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classhmap_1_1Array}{Array}} hmap\+::\+Graph\+::to\+\_\+array\+\_\+sdf (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structhmap_1_1Vec2}{Vec2}}$<$ int $>$}]{shape,  }\item[{\mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$}]{bbox,  }\item[{\mbox{\hyperlink{classhmap_1_1Array}{Array}} \texorpdfstring{$\ast$}{*}}]{p\+\_\+noise\+\_\+x = {\ttfamily nullptr},  }\item[{\mbox{\hyperlink{classhmap_1_1Array}{Array}} \texorpdfstring{$\ast$}{*}}]{p\+\_\+noise\+\_\+y = {\ttfamily nullptr},  }\item[{\mbox{\hyperlink{structhmap_1_1Vec4}{Vec4}}$<$ float $>$}]{bbox\+\_\+array = {\ttfamily \{0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}},~1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}},~0.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}},~1.\mbox{\hyperlink{distance__transform_8cpp_abcb9259cf91bfd25e92a72cdf18c285e}{f}}\}} }\end{DoxyParamCaption})}



Generate an array filled with the Signed Distance \doxylink{classhmap_1_1Function}{Function} (SDF) to the graph. 

This method computes the signed distance function for the graph, which measures the distance of each point in the array to the nearest edge of the graph. The result is projected onto an output array. The optional noise arrays can be used for domain warping.


\begin{DoxyParams}{Parameters}
{\em shape} & The shape of the output array. \\
\hline
{\em bbox} & The bounding box defining the area over which the SDF is computed. \\
\hline
{\em p\+\_\+noise\+\_\+x} & Reference to the input noise array for domain warping in the x-\/direction (optional). \\
\hline
{\em p\+\_\+noise\+\_\+y} & Reference to the input noise array for domain warping in the y-\/direction (optional). \\
\hline
{\em bbox\+\_\+array} & The bounding box of the destination array. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\doxylink{classhmap_1_1Array}{Array} The resulting array with the signed distance function values.
\end{DoxyReturn}
{\bfseries{Example}} 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{highmap_8hpp}{highmap.hpp}}"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ main(\textcolor{keywordtype}{void})}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{structhmap_1_1Vec2}{hmap::Vec2<int>}}\ shape\ =\ \{256,\ 256\};}
\DoxyCodeLine{\ \ \mbox{\hyperlink{array_8hpp_a91ad9478d81a7aaf2593e8d9c3d06a14}{uint}}\ \ \ \ \ \ \ \ \ \ \ \ seed\ =\ 1;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacehmap_a03c0be3a7198eebacefcb208b0cfee99}{noise}}\ =\ \mbox{\hyperlink{namespacehmap_a40b948c49a05c14f2d540dc1a6952130}{hmap::noise\_fbm}}(\mbox{\hyperlink{namespacehmap_ab8197c4c7a85dacb616fee7a7d0df195a87c6abee9c8e2441859223b28e9b4581}{hmap::NoiseType::PERLIN}},\ shape,\ \{2,\ 2\},\ seed);}
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacehmap_a262e6495cb2d02598f36a2b46114b2b4}{hmap::remap}}(\mbox{\hyperlink{namespacehmap_a03c0be3a7198eebacefcb208b0cfee99}{noise}},\ 0.f,\ 0.2f);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{structhmap_1_1Vec4}{hmap::Vec4<float>}}\ bbox\ =\ \{0.2f,\ 0.8f,\ 0.2f,\ 0.8f\};}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classhmap_1_1Cloud}{hmap::Cloud}}\ \ \ \ \ \ \ cloud\ =\ \mbox{\hyperlink{classhmap_1_1Cloud}{hmap::Cloud}}(5,\ seed,\ bbox);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{structhmap_1_1Vec4}{hmap::Vec4<float>}}\ bbox\_array\ =\ \{0.f,\ 1.f,\ 0.f,\ 1.f\};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classhmap_1_1Array}{hmap::Array}}\ z\_sdf1\ =\ cloud.\mbox{\hyperlink{classhmap_1_1Cloud_a04dcb02dd2df076553e410dbcceb2c35}{to\_array\_sdf}}(shape,\ bbox\_array);}
\DoxyCodeLine{\ \ \mbox{\hyperlink{classhmap_1_1Array}{hmap::Array}}\ z\_sdf2\ =\ cloud.\mbox{\hyperlink{classhmap_1_1Cloud_a04dcb02dd2df076553e410dbcceb2c35}{to\_array\_sdf}}(shape,\ bbox\_array,\ \&\mbox{\hyperlink{namespacehmap_a03c0be3a7198eebacefcb208b0cfee99}{noise}},\ \&\mbox{\hyperlink{namespacehmap_a03c0be3a7198eebacefcb208b0cfee99}{noise}});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespacehmap_a1c490f296571a75e35d05b10c075ae6c}{hmap::export\_banner\_png}}(\textcolor{stringliteral}{"{}ex\_cloud\_sdf.png"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{z\_sdf1,\ z\_sdf2\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacehmap_ac70fe3cbb32e0340d5dd3e15cdcf9369a65146260717d07e4773aec50520b9ced}{hmap::Cmap::JET}});}
\DoxyCodeLine{\}}

\end{DoxyCodeInclude}
 Result\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}  \Hypertarget{classhmap_1_1Graph_a47f4e4792141971443d9dbeb714ae612}\label{classhmap_1_1Graph_a47f4e4792141971443d9dbeb714ae612} 
\index{hmap::Graph@{hmap::Graph}!to\_csv@{to\_csv}}
\index{to\_csv@{to\_csv}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{to\_csv()}{to\_csv()}}
{\footnotesize\ttfamily void hmap\+::\+Graph\+::to\+\_\+csv (\begin{DoxyParamCaption}\item[{std\+::string}]{fname\+\_\+xy,  }\item[{std\+::string}]{fname\+\_\+adjacency }\end{DoxyParamCaption})}



Export graph data to CSV files. 

This method exports the graph data to two separate CSV files\+: one for node coordinates and one for the adjacency matrix. The node coordinates file contains the {\ttfamily (x, y)} coordinates of the graph\textquotesingle{}s nodes, and the adjacency matrix file contains the graph\textquotesingle{}s connectivity information.


\begin{DoxyParams}{Parameters}
{\em fname\+\_\+xy} & Filename for the CSV file containing node {\ttfamily (x, y)} coordinates. \\
\hline
{\em fname\+\_\+adjacency} & Filename for the CSV file containing the adjacency matrix. \\
\hline
\end{DoxyParams}
\Hypertarget{classhmap_1_1Graph_a9ceef3779f34960009226304494d5f6c}\label{classhmap_1_1Graph_a9ceef3779f34960009226304494d5f6c} 
\index{hmap::Graph@{hmap::Graph}!to\_png@{to\_png}}
\index{to\_png@{to\_png}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{to\_png()}{to\_png()}}
{\footnotesize\ttfamily void hmap\+::\+Graph\+::to\+\_\+png (\begin{DoxyParamCaption}\item[{std\+::string}]{fname,  }\item[{\mbox{\hyperlink{structhmap_1_1Vec2}{Vec2}}$<$ int $>$}]{shape = {\ttfamily \{512,~512\}} }\end{DoxyParamCaption})}



Export the graph as a PNG image file. 

This method exports a visual representation of the graph as a PNG image file. The resolution of the image can be specified using the {\ttfamily shape} parameter.


\begin{DoxyParams}{Parameters}
{\em fname} & The file name for the PNG image. \\
\hline
{\em shape} & The resolution of the image in pixels (width, height). \\
\hline
\end{DoxyParams}
\Hypertarget{classhmap_1_1Graph_a6accdaeaf48a49a3a751f4a83e59df47}\label{classhmap_1_1Graph_a6accdaeaf48a49a3a751f4a83e59df47} 
\index{hmap::Graph@{hmap::Graph}!update\_adjacency\_matrix@{update\_adjacency\_matrix}}
\index{update\_adjacency\_matrix@{update\_adjacency\_matrix}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{update\_adjacency\_matrix()}{update\_adjacency\_matrix()}}
{\footnotesize\ttfamily void hmap\+::\+Graph\+::update\+\_\+adjacency\+\_\+matrix (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Update the adjacency matrix of the graph. 

This method updates the adjacency matrix based on the current graph edges and weights. The adjacency matrix represents the connectivity between nodes in the graph. \Hypertarget{classhmap_1_1Graph_ad37ed278a791b43779733f7f22187f15}\label{classhmap_1_1Graph_ad37ed278a791b43779733f7f22187f15} 
\index{hmap::Graph@{hmap::Graph}!update\_connectivity@{update\_connectivity}}
\index{update\_connectivity@{update\_connectivity}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{update\_connectivity()}{update\_connectivity()}}
{\footnotesize\ttfamily void hmap\+::\+Graph\+::update\+\_\+connectivity (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Update the point connectivity information. 

This method updates the point connectivity data, which describes the relationships between nodes in the graph based on the current edges. 

\doxysubsection{Member Data Documentation}
\Hypertarget{classhmap_1_1Graph_ae6a15dbafff50f5aa083c975292acffd}\label{classhmap_1_1Graph_ae6a15dbafff50f5aa083c975292acffd} 
\index{hmap::Graph@{hmap::Graph}!edges@{edges}}
\index{edges@{edges}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{edges}{edges}}
{\footnotesize\ttfamily std\+::vector$<$std\+::vector$<$int$>$ $>$ hmap\+::\+Graph\+::edges = \{\}}



Edges of the graph. 

This member variable stores the edges of the graph. Each edge is represented as a pair of indices referring to the vertices in the graph. The edges are stored as a vector of vectors, where each inner vector contains the indices of vertices connected by that edge. \Hypertarget{classhmap_1_1Graph_a72f35dca4fd9c5f061bdc6b2ad70cb5e}\label{classhmap_1_1Graph_a72f35dca4fd9c5f061bdc6b2ad70cb5e} 
\index{hmap::Graph@{hmap::Graph}!weights@{weights}}
\index{weights@{weights}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{weights}{weights}}
{\footnotesize\ttfamily std\+::vector$<$float$>$ hmap\+::\+Graph\+::weights = \{\}}



\doxylink{classhmap_1_1Edge}{Edge} weights. 

This member variable stores the weights associated with the edges of the graph. Each weight corresponds to an edge and is stored in a vector. The weights are used to represent the cost or distance associated with traveling along an edge in the graph. \Hypertarget{classhmap_1_1Graph_ac4fa0788cdc6162d9254b059ae9857da}\label{classhmap_1_1Graph_ac4fa0788cdc6162d9254b059ae9857da} 
\index{hmap::Graph@{hmap::Graph}!connectivity@{connectivity}}
\index{connectivity@{connectivity}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{connectivity}{connectivity}}
{\footnotesize\ttfamily std\+::vector$<$std\+::vector$<$int$>$ $>$ hmap\+::\+Graph\+::connectivity = \{\}}



Store point connectivity. 

This member variable stores the connectivity information of the points in the graph. It is represented as a vector of vectors, where each inner vector contains the indices of neighboring vertices connected to the corresponding point. \Hypertarget{classhmap_1_1Graph_a93e452d7229b47e83f431502a18f68da}\label{classhmap_1_1Graph_a93e452d7229b47e83f431502a18f68da} 
\index{hmap::Graph@{hmap::Graph}!adjacency\_matrix@{adjacency\_matrix}}
\index{adjacency\_matrix@{adjacency\_matrix}!hmap::Graph@{hmap::Graph}}
\doxysubsubsection{\texorpdfstring{adjacency\_matrix}{adjacency\_matrix}}
{\footnotesize\ttfamily std\+::map$<$std\+::pair$<$int, int$>$, float$>$ hmap\+::\+Graph\+::adjacency\+\_\+matrix}



Adjacency matrix. 

This member variable represents the adjacency matrix of the graph. It is a map where each key is a pair of vertex indices and the value is the weight of the edge connecting those vertices. The adjacency matrix provides a way to quickly access the weight of an edge between any two vertices. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
High\+Map/include/highmap/geometry/\mbox{\hyperlink{graph_8hpp}{graph.\+hpp}}\item 
High\+Map/src/geometry/\mbox{\hyperlink{graph_8cpp}{graph.\+cpp}}\end{DoxyCompactItemize}
